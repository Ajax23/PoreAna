import os
import sys
import math
import warnings

import random
import scipy as sp
import numpy as np
import chemfiles as cf
import pandas as pd

import seaborn as sns
import matplotlib.pyplot as plt

import poreana.utils as utils



def diffusion(link, len_step=[], is_std = False):
    """
    This function use the diffusion profiles over the bins from the function :func:`do_mc_cycles` to caluclate the final diffusion coefficient. For that a line is fit of the mean diffusion :math:`D_{mean}({t_i})` for the different lagtimes as a function of :math:`1/t_i` . The function plot all mean diffusion :math:`D_{mean}({t_i})` over all inverse input lagtimes and the linear fit. Additional the final mean diffusion coefficient :math:`D` for a lagtime :math:`t_i \\rightarrow \infty` is printed. Also a table of the selected step length and the belonging :math:`D_{mean}({t_i})` can be displayed

    Parameters
    ----------
    link: string
        link to the diffusion data object generated by the sample routine :func: `sample_box`
    len_step: integer list, optional (default = None)
        list of the different step length, if it is None the lag times which are contains in the obj file are printed

    Returns
    -------
    diffusion: float
        diffusion coefficient :math:`D \ (\\frac{m^2}{s})` for the calculated system
    diff_table : obj
        table of used lag times for fitting of :math:`D \ (\\frac{m^2}{s})`
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_profile"]
    inp = results["model"]
    diff_unit = inp["diffusion unit"]
    dt = inp["len_frame"]

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
        len_step = inp["len_step"]


    # Calculate the standard deviation
    if is_std:
        set_size = 100
        rand = np.zeros((100,4),int)
        res = np.zeros(set_size)
        res_sum = 0
        delta = 0
        for i in range(set_size):
            for j in range(4):
                len_rand = random.sample(len_step,k=4)
                rand[i] = len_rand
                #print(rand)
            # Calculate the mean diffusion over all bins
            D_mean = [np.mean(np.exp(diff_bin[i] + diff_unit)) * 10**-6 for i in rand[i]]   # Diffusion in m^2/s

            # Calculate the inverse lag time for the linear fit
            lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(rand[i]))]   # Inverse lagtime in s

            # fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

            # set the x value for the linear fit
            x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5 )

            res[i] = fit(0)

        res_sum = np.mean(res)
        for i in range(set_size):
            delta += (res[i] - res_sum)**2

        std = np.sqrt(delta/set_size)
        print(std)

    # Calculate the mean diffusion over all bins
    D_mean = [np.mean(np.exp(diff_bin[i] + diff_unit)) * 10**-6 for i in len_step]   # Diffusion in m^2/s

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]   # Inverse lagtime in s

    # fit a linear line
    fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

    # set the x value for the linear fit
    x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5 )

    # Calculate the diffusion coefficient as a mean value over the bin
    print("\nDiffusion: "+"%.4e" % fit(0)  +" m^2/s\n\n")
    if is_std:
        print("\nMean Diffusion: "+"%.4e" % np.mean(res)  +" m^2/s\n\n")
        print("\nStandard deviation: "+"%.4e" % std  +" m^2/s\n\n")

    # Set data frame for the used lag times
    data = [str("%.2e" % D_mean[i]) + " $\mathrm{m^2s^{-1}}$" for i in range(len(len_step))]
    diff_table = pd.DataFrame(data,index=list(len_step),columns=list(['$D_\mathrm{mean}$']))
    diff_table = pd.DataFrame(diff_table.rename_axis('Step Length', axis=1))
    # styler = diff_table.style.set_caption('Selected step length')
    # diff_table =styler.set_properties(**{'text-align': 'right'})
    # diff_table = diff_table.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])


    # Plot the results
    plt.xlim(-0.5,1.5*max(lagtime_inverse))
    plt.ylim(0,1.5*max(fit(x)))
    sns.scatterplot(x=lagtime_inverse, y=D_mean,color ='red')
    sns.lineplot(x=x, y=fit(x))
    sns.scatterplot(x=[0.0], y=[fit(0)],color ='black')
    legend = ["linear fit","$D_{\mathrm{mean}}$"]
    plt.legend(legend)
    plt.xlabel(r"Inverse lagtime ($\mathrm{s^{-1}})$")
    plt.ylabel(r"Diffusion ($\mathrm{m^2s^{-1}}$)")


    return fit(0),diff_table


def diffusion_radial(link, len_step=None):
    """
    This function use the diffusion profiles over the bins from the function :func:`do_mc_cycles` to caluclate the final diffusion coefficient. For that a line is fit of the mean diffusion :math:`D_{mean}({t_i})` for the different lagtimes as a function of :math:`1/t_i` . The function plot all mean diffusion :math:`D_{mean}({t_i})` over all inverse input lagtimes and the linear fit. Additional the final mean diffusion coefficient :math:`D` for a lagtime :math:`t_i \\rightarrow \infty` is printed. Also a table of the selected step length and the belonging :math:`D_{mean}({t_i})` and the :math:`D_{avg}({t_i})` can be displayed

    Formel f√ºr avg falls das drin bleibt

    Parameters
    ----------
    link: string
        link to the diffusion data object generated by the sample routine :func: `sample_box`
    len_step: integer list, optional (default = None)
        list of the different step length, if it is None the lag times which are contains in the obj file are printed

    Returns
    -------
    diffusion: float
        diffusion coefficient :math:`D \ (\\frac{m^2}{s})` for the calculated system
    diff_table : obj
        table of used lag times for fitting of :math:`D \ (\\frac{m^2}{s})`
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_radial_profile"]
    df_bin = results["df_profile"]
    inp = results["model"]
    bins = inp["bins"]
    diff_unit = inp["diffusion radial unit"]
    dt = inp["len_frame"]

    #
    if len_step is None:
        len_step = inp["len_step"]

    # Calculate the mean diffusion over all bins
    D_mean = [np.mean(np.exp(diff_bin[i] + diff_unit)) * 10**-6 for i in len_step]   # Diffusion in m^2/s

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]   # Inverse lagtime in s

    # fit a linear line
    fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

    # set the x value for the linear fit
    x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5 )


    # Calculate the diffusion coefficient as a mean value over the bin
    print("\nMean Radial Diffusion: "+"%.4e" % fit(0)  +" m^2/s\n")

    # Integration
    bin_width = bins[1]-bins[0]

    # Determine averaged diffusion weight with the free energy profile
    diff_avg = [(np.trapz(np.exp(df_bin[i])*np.exp(diff_bin[i] + diff_unit), bins, bin_width) / np.trapz(np.exp(df_bin[i]), bins, bin_width)) * 10**-6 for i in len_step]

    # Set data frame for the used lag times
    D_mean_pd = [str("%.2e" % D_mean[i]) for i in range(len(D_mean))]
    diff_avg_pd = [str("%.2e" % diff_avg[i]) for i in range(len(diff_avg))]
    diff_table = pd.DataFrame({'$D_\mathrm{mean}$':D_mean_pd,'$D_\mathrm{avg} (\mathrm{m^2s^{-1}})$': diff_avg_pd},index=list(len_step))
    diff_table = pd.DataFrame(diff_table.rename_axis('Step Length', axis=1))
    styler = diff_table.style.set_caption('Selected step length')
    diff_table =styler.set_properties(**{'text-align': 'right'})
    diff_table = diff_table.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])


    # Plot the results
    plt.xlim(0,1.5*max(lagtime_inverse))
    plt.ylim(0,1.5*max(fit(x)))
    sns.scatterplot(x=lagtime_inverse, y=D_mean,color ='red')
    sns.lineplot(x=x, y=fit(x))
    legend = ["linear fit","$D_{\mathrm{mean}}$"]
    plt.legend(legend)
    plt.xlabel(r"Inverse lagtime ($\mathrm{s^{-1}})$")
    plt.ylabel(r"radial Diffusion ($\mathrm{m^2s^{-1}}$)")

    return fit(0),diff_table

def diffusion_pore(link_pore, link, len_step=None):
    """
    This function use the diffusion profiles over the bins from the function :func:`do_mc_cycles` to caluclate the final diffusion coefficient in a pore. For that a line is fit of the mean diffusion :math:`D_{mean}({t_i})` for the different lagtimes as a function of :math:`1/t_i` . The function plot all mean diffusion :math:`D_{mean}({t_i})` in the pore over all inverse input lagtimes and the linear fit. Additional the final mean diffusion coefficient :math:`D` for a lagtime :math:`t_i \\rightarrow \infty` is printed. Also a table of the selected step length and the belonging :math:`D_{mean}({t_i})` can be displayed

    Parameters
    ----------
    link_pore : string
        Link to poresystem object file
    link: string
        link to the diffusion data object generated by the sample routine :func: `sample_box`
    len_step: integer list, optional (default = None)
        list of the different step length, if it is None the lag times which are contains in the obj file are printed

    Returns
    -------
    diffusion: float
        diffusion coefficient :math:`D \ (\\frac{m^2}{s})` for the calculated system
    diff_table : obj
        table of used lag times for fitting of :math:`D \ (\\frac{m^2}{s})`
    """


    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_profile"]
    df_bin = results["df_profile"]
    inp = results["model"]
    bins = inp["bins"]
    diff_unit = inp["diffusion unit"]
    dt = inp["len_frame"]
    bins = [(bins[i] + (bins[1]-bins[0]))   for i in range(len(bins))]
    diff_bin_pore = {}
    diff = np.zeros(len(bins))
    # Load pore obj file
    pore = utils.load(link_pore)
    res = pore.reservoir()
    box = pore.box()

    if len_step is None:
        len_step = inp["len_step"]

    # Cut profile
    index_start = np.digitize(res,bins)
    index_end  = np.digitize((res + box[2]), bins)
    for i in len_step:
            diff_bin_pore[i] = {}
            diff = diff_bin[i]
            diff_bin_pore[i] = diff[index_start:index_end]

    # Calculate the mean diffusion over all bins
    D_mean = [np.mean(np.exp(diff_bin_pore[i] + diff_unit)) * 10**-6 for i in len_step]   # Diffusion in m^2/s

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]   # Inverse lagtime in s

    # Plot the diffusion profiles for the different lag times
    legend = ["lagtime " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

    # fit a linear line
    fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

    # set the x value for the linear fit
    x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5 )

    # Calculate the diffusion coefficient as a mean value over the bin
    print("\nMean Diffusion (Pore): "+"%.4e" % fit(0)  +" m^2/s\n")

    # Set data frame for the used lag times
    data = [str("%.4e" % D_mean[i]) + " $\mathrm{m^2s^{-1}}$" for i in range(len(len_step))]
    diff_table = pd.DataFrame(data,index=list(len_step),columns=list(['$D_\mathrm{mean}$']))
    diff_table = pd.DataFrame(diff_table.rename_axis('Step Length', axis=1))
    styler = diff_table.style.set_caption('Selected step length')
    diff_table =styler.set_properties(**{'text-align': 'right'})
    diff_table = diff_table.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])


    # Plot the results
    plt.xlim(-0.5,1.5*max(lagtime_inverse))
    plt.ylim(0,1.5*max(fit(x)))
    sns.scatterplot(x=lagtime_inverse, y=D_mean,color ='red')
    sns.scatterplot(x=[0.0], y=[fit(0)],color ='black')
    sns.lineplot(x=x, y=fit(x))
    legend = ["linear fit","$D_{\mathrm{mean}}$"]
    plt.legend(legend)
    plt.xlabel(r"Inverse lagtime ($\mathrm{s^{-1}})$")
    plt.ylabel(r"radial Diffusion ($\mathrm{m^2s^{-1}}$)")

    return fit(0),diff_table

def diff_pore_profile(link_pore, link, len_step=None, infty_profile = False):
    """
    This function plots the diffusion profile in the pore over pore length for serveral lagtimes.

    Parameters
    ----------
    link_pore : string
        Link to poresystem object file
    link : string
        link to the diffusion data object generated by the :func:`do_mc_cycles`
    len_step: integer list, optional (default = None)
        list of the different step length, if it is None the lag times which are contains in the obj file are printed
    infty_profile : bool (default = False)
        if its True only the profile for an infity lagtime is plotted
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_profile"]
    df_bin = results["df_profile"]
    inp = results["model"]
    bins = inp["bins"]
    diff_unit = inp["diffusion unit"]
    dt = inp["len_frame"]
    bins = [(bins[i] + (bins[1]-bins[0]))   for i in range(len(bins))]
    diff_bin_pore = {}
    diff = np.zeros(len(bins))
    # Load pore obj file
    pore = utils.load(link_pore)
    res = pore.reservoir()
    box = pore.box()
    legend = []



    if len_step is None:
        len_step = inp["len_step"]

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]   # Inverse lagtime in s

    # Cut profile
    index_start = np.digitize(res,bins)
    index_end  = np.digitize((res + box[2]), bins)
    for i in len_step:
            diff_bin_pore[i] = {}
            diff = diff_bin[i]
            diff_bin_pore[i] = diff[index_start:index_end]

    bins_pore = [bins[i] - res for i in range(index_start,index_end)]

    if infty_profile == False:
        # Plot the diffusion profiles for the different lag times
        legend = ["lagtime " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

        # Plot the profiles for the
        for i in len_step:
            sns.lineplot(x=(bins_pore), y=np.exp(diff_bin_pore[i] + diff_unit) * 10**-6)       # Diffusion in m^2/s



    if len(len_step)>=2:
        # Initialize fit vector
        diff_profile_fit = []

        # Calculate the mean diffusion over all bins
        for i in range(len(bins_pore)):
            diff = [np.exp(diff_bin_pore[step][i] + diff_unit) * 10**-6 for step in len_step]   # Diffusion in m^2/s

            # fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse,diff,1))

            #Append diffusion at t-> infty
            diff_profile_fit.append(fit(0))

        # Plot fitted diffusion profile
        sns.lineplot(x=(bins_pore), y = diff_profile_fit)       # Diffusion in m^2/s

        if infty_profile == False:
            # Add legend
            legend.append("Lagtime $\\infty$ ps")
            plt.legend(legend)

    # Set plot properties
    plt.xlabel(r"pore length (nm)")
    plt.ylabel(r"Diffusion ($\mathrm{m^2s^{-1}}$)")




def diff_profile(link,len_step=None, infty_profile = False):
    """
    This function plots the diffusion profile over the box for serveral lagtimes.

    Parameters
    ----------
    link : string
        link to the diffusion data object generated by the :func:`do_mc_cycles`
    len_step : integer list, optional (default = None)
        list of the different step length, if it is None the lag times which are contains in the obj file are printed
    infty_profile : bool (default = False)
        if its True only the profile for an infity lagtime is plotted
    """
    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_profile"]
    df_bin = results["df_profile"]
    inp = results["model"]
    diff_unit = inp["diffusion unit"]
    dt = inp["len_frame"]
    bins = inp["bins"]
    bins = [(bins[i] + (bins[1]-bins[0])) for i in range(len(bins))]
    legend = []

    if len_step is None:
        len_step = inp["len_step"]



    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]   # Inverse lagtime in s

    if infty_profile == False:
        # Plot the profiles for the
        for i in len_step:
            sns.lineplot(x=bins, y=np.exp(diff_bin[i] + diff_unit) * 10**-6)       # Diffusion in m^2/s

        # Plot the diffusion profiles for the different lag times
        legend = ["lagtime " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]


    if len(len_step)>=2:

        # Initialize fit vector
        diff_profile_fit = []

        # Calculate the mean diffusion over all bins
        for i in range(len(bins)):
            diff = [np.exp(diff_bin[step][i] + diff_unit) * 10**-6 for step in len_step]   # Diffusion in m^2/s

            # fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse,diff,1))

            #Append diffusion at t-> infty
            diff_profile_fit.append(fit(0))

        # Plot fitted diffusion profile
        sns.lineplot(x=bins, y = diff_profile_fit)       # Diffusion in m^2/s

        if infty_profile == False:
            # Add legend
            legend.append("Lagtime $\\infty$ ps")
            plt.legend(legend)

    # Set plot properties
    plt.xlabel(r"box length (nm)")
    plt.ylabel(r"Diffusion ($\mathrm{m^2s^{-1}}$)")




def df_profile(link,len_step=None):
    """
    This function plots the free energy profile over the box for serveral lagtimes.

    Parameters
    ----------
    link : string
        link to the diffusion data object generated by the :func:`do_mc_cycles`
    len_step: integer list, optional (default = None)
        list of the different step length, if it is None the lag times which are contains in the obj file are printed
    """

    # Load Results from the output object file
    results = utils.load(link)
    df_bin = results["df_profile"]
    inp = results["model"]
    dt = inp["len_frame"]
    bins = inp["bins"]
    #bins = (bins + bins[1]-bins[0]) * 10**-8   # in m

    if len_step is None:
        len_step = inp["len_step"]

    legend = ["lagtime " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]


    # Plot the free energy profiles
    for i in len_step:
         sns.lineplot(x=bins, y=(df_bin[i]))

    plt.xlabel(r"Box length (nm)")
    plt.ylabel(r"Free energy ($\mathrm{J^{-1}}$)")
    plt.legend(legend)


def diff_radial_profile(link,len_step=None,avg=False):
    """
    This function plots the radial diffusion profile over the box for serveral lagtimes.

    Parameters
    ----------
    link : string
        link to the diffusion data object generated by the :func:`do_mc_cycles`
    len_step: integer list, optional (default = None)
        list of the different step length, if it is None the lag times which are contains in the obj file are printed
    avg: bool
        if its True a averaged profile of all selected lagtimes is plotted too

    Returns
    -------
    diffusion: float
        diffusion coefficient :math:`D \ (\\frac{m^2}{s})` for the calculated system
    diff_table : obj
        table of used lag times for fitting of :math:`D \ (\\frac{m^2}{s})`
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_radial_profile"]
    inp = results["model"]
    dt = inp["len_frame"]
    diff_unit = inp["diffusion radial unit"]
    bins = inp["bins"]
    bins = [(bins[i]) * 10**-8   for i in range(len(bins))]

    if len_step is None:
        len_step = inp["len_step"]

    # Plot the diffusion profiles for the different lag times
    legend = ["lagtime " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

    # Plot the profiles for the
    for i in len_step:
        sns.lineplot(x=bins, y=np.exp(diff_bin[i] + diff_unit) * 10**-6)       # Diffusion in m^2/s


    # Averged profile over the selected lag times
    if len(len_step) != 1 and avg==True:
        diff_mean = np.zeros(len(bins[:-1]))
        diff = []
        for i in len_step:
            diff_mean += diff_bin[i]
        diff = [diff_mean[i]/len(len_step) for i in range(len(diff_mean))]

        # Plot mean profile over the selected lag times
        sns.lineplot(x=bins, y=np.exp(diff + diff_unit) * 10**-6)       # Diffusion in m^2/s
        legend.append("avg profile")

    # Set plot properties
    plt.xlabel(r"box length (m)")
    plt.ylabel(r"radial Diffusion ($\mathrm{m^2s^{-1}}$)")
    plt.legend(legend)



def print_statistics_mc(link_out, print_con=False):
    """
    This function print the statistic of the MC Run over the serveral step length

    Parameters
    ----------
    link_out: string
        link to the diffusion data object generated by the sample routine :func:`moldyn.pores.mcdiff.mc.do_mc_cycles`

    Returns
    -------
    df_results: obj
        data frame of the MC Alogrithm statistics
    """

    # If a data object output as an input take the results
    results = utils.load(link_out)
    model = results["model"]
    len_step = model["len_step"]
    inp = results["inp"]
    nmc_eq = inp["MC steps eq"]
    nmc = inp["MC steps"]
    nmc_radial_eq = inp["MC steps radial eq"]
    nmc_radial = inp["MC steps radial"]
    num_mc_update = inp["step width update"]
    print_freq = inp["print freq"]

    #Read MC statistic
    nacc_df_mean = results["nacc_df"]
    nacc_diff_mean = results["nacc_diff"]
    nacc_diff_radial_mean = results["nacc_diff_radial"]
    list_diff_fluc = results["fluc_diff"]
    list_df_fluc = results["fluc_df"]
    list_diff_radial_fluc = results["fluc_diff_radial"]


    # Table for MC Statistics
    data = [[str("%.4e" % list_df_fluc[i]) for i in len_step],[str("%.4e" % list_diff_fluc[i]) for i in len_step],[str("%.4e" % list_diff_radial_fluc[i]) for i in len_step],[str("%.0f" % nacc_df_mean[i]) for i in len_step],[str("%.0f" % nacc_diff_mean[i]) for i in len_step],[str("%.0f" % nacc_diff_radial_mean[i]) for i in len_step],[str("%.2f" % (nacc_df_mean[i]*100/(nmc+nmc_eq))) for i in len_step],[str("%.2f" % (nacc_diff_mean[i]*100/(nmc+nmc_eq))) for i in len_step],[str("%.2f" % float(nacc_diff_radial_mean[i]*100/(nmc_radial+nmc_radial_eq))) for i in len_step]]

    df_results = pd.DataFrame(data,index=list(['fluctuation df','fluctuation diff','fluctuation rad. diff','acc df steps','acc diff steps','acc rad. diff steps','acc df steps (%)','acc diff steps (%)','acc rad. diff steps (%)']),columns=list(len_step))

    # If the table has to print in console
    if print_con==True:
        print('\nStatistics of the MC Algorithm')
        print(df_results)

    # Set styler for pandas table in jupyter
    df_results = pd.DataFrame(df_results.rename_axis('Step Length', axis=1))
    styler = df_results.style.set_caption('Statistics of the MC Algorithm')
    df_results = styler.set_properties(**{'text-align': 'right'})
    df_results = df_results.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])

    return df_results


def plot_trans_mat(link_in,step,kwargs={},rad=False):
    """
    This function plots the occupation of a normalized transition matrix as an heatmap. To normalize the matrix the number of the frame are used.

    Parameters
    ----------
    link_in: string
        link to the diffusion sample obj file generated by the sample routine :func:`moldyn.pores.sample`
    step: int
        step length for the trans matrix to be visualized
    kwargs: dict
        dictionary with heatmap parameters to adjust the transition heatmap


    """
    results = utils.load(link_in)

    #trans_mat_radial = results["trans_mat_radial"]
    model = results["model"]
    trans_mat = model["trans_mat"]
    frame_num = model["num_frame"]
    frame_length = model["len_frame"]
    #bin_radial = inp["bins_radial"]
    


    plt.title("Lagtime: "+str(step * frame_length) + " ps", fontsize=10)
    if not kwargs:
        sns.heatmap(trans_mat[step]/frame_num)
    else:
        sns.heatmap(trans_mat[step]/frame_num, **kwargs)
    #plt.show()

    # if rad == True:
    #     for i in len_step:
    #         for j in range(bin_radial):
    #             plt.title("radial_bin: "+str(j))
    #             sns.heatmap(trans_mat_radial[i][j])
    #             plt.show()
