import os
import sys
import math
import warnings

import random
import scipy as sp
import numpy as np
import chemfiles as cf
import pandas as pd
import itertools

import seaborn as sns
import matplotlib.pyplot as plt

import poreana.utils as utils


#############
# Diffusion #
#############
def diffusion(link, len_step=[], is_std = True):
    """
    This function uses the diffusion profiles over box length which are calculated in the function :func:`do_mc_cycles` to estimate the final diffusion coefficient. For that a line is fitted of the averaged diffusion profiles :math:`D_{mean}({\\Delta_{ij}t_{alpha}})` for the different lag times as a function of :math:`1/\\Delta_{ij}t_{alpha}`. The function plots all mean diffusion :math:`D_{mean}({\\Delta_{ij}t_{alpha}})` over the inverse lag times and the linear fit. Additional the final mean diffusion coefficient :math:`D` for a lagtime :math:`\\Delta_{ij}t_{alpha} \\rightarrow \infty` is printed. Also a table of the selected step length and the belonging :math:`D_{mean}({\\Delta_{ij}t_{alpha}})` can be displayed.

    In order to be able to estimate how the choice of lag times affects the result, an additional error estimation is possible. For this all possible fourth tuples of the entire calculated lag times are used to estimate a mean diffusion coefficient :math:`\\langle D \\rangle` which is the mean value of all fourth tuples fitting results. Also the standard deviation of all fitting results is printed. If there is no big difference between the diffusion coefficient :math:`D` and the mean diffusion ceofficient :math:`\\langle D \\rangle`, all :math:`D_{mean}({\\Delta_{ij}t_{alpha}})` are on a straight line. The standard deviation can also be used to check if the result fluctuates strongly at the choice of other lag times. This error estimate is calculated if :math:`is_std=True`.

    Parameters
    ----------
    link: string
        link to the diffusion data object generated by the sample routine :func: `sample_box`
    len_step: integer list, optional (default = [])
        list of the different step length, if it is None the lag times which are contains in the obj file are printed
    is_std : bool (default=True)
        if it is true a mean diffusion coefficient and a Bootstrap diffusion is calculated to be able to assess the dependency of the results on the chosen lag time

    Returns
    -------
    diffusion: float
        diffusion coefficient :math:`D \ (\\frac{m^2}{s})` for the calculated system
    diff_table : obj
        table of used lag times for fitting of :math:`D \ (\\frac{m^2}{s})`
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_profile"]
    inp = results["model"]
    diff_unit = inp["diffusion unit"]
    dt = inp["len_frame"]

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
        len_step = inp["len_step"]

    # Calculate mean diffusion coefficient and standard deviation
    # Mean diffusion means the averaged of all pssible fourth tuple fitting results
    if is_std:
        len_step_all = len_step

        # Determine all possible combinations
        a = list(itertools.combinations(len_step_all,2))

        # Allocate the results vector
        res = np.zeros(len(a))

        # Fit for all combinations
        for i in range(len(a)):

            # set the current tuple
            rand = list(a[i])

            # Calculate the mean diffusion over all bins
            D_mean = [np.mean(np.exp(diff_bin[i] + diff_unit)) * 10**-6 for i in rand]  # Diffusion in m^2/s

            # Calculate the inverse lag time for the linear fit
            lagtime_inverse = [ 1 / (i * dt * 10**-12) for i in rand]   # Inverse lagtime in s

            # fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

            # set the x value for the linear fit
            x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5 )

            # Set the fitted diffusion coefficient on the results list
            res[i] = fit(0)

        # Determine standard deviation and mean diffusion of fourth touple method
        res_sum = np.mean(res)
        std = res.std()

    # Bootstrap calculation
    if is_std:
        set_size = 10000
        rand = np.zeros((10000,4),int)
        res = np.zeros(set_size)
        len_step_all = len_step
        for i in range(set_size):
            for j in range(4):
                len_rand = random.sample(len_step_all,k=4)
                rand[i] = len_rand

            # Calculate the mean diffusion over all bins
            D_mean = [np.mean(np.exp(diff_bin[i] + diff_unit)) * 10**-6 for i in rand[i]]   # Diffusion in m^2/s

            # Calculate the inverse lag time for the linear fit
            lagtime_inverse = [ 1 / (len_step_all[i] * dt * 10 ** -12) for i in range(len(rand[i]))]   # Inverse lagtime in s

            # fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

            # set the x value for the linear fit
            x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5 )

            # Set the fitted diffusion coefficient on the results list
            res[i] = fit(0)

        # Mean diffusion of Bootstrap and standard deviation of Bootstrap
        res_sum_2 = np.mean(res)
        std_2 = res.std()


    # Calculate the mean diffusion over all bins
    D_mean = [np.mean(np.exp(diff_bin[i] + diff_unit)) * 10**-6 for i in len_step]   # Diffusion in m^2/s

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]   # Inverse lagtime in s

    # fit a linear line
    fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

    # Calculate the diffusion coefficient as a mean value over the bin
    print("\nDiffusion: "+"%.4e" % fit(0)  +" m^2/s\n\n")

    # If is_std true print the results of the calculations
    if is_std:
        print("\nMean Diffusion: "+"%.4e" % res_sum  +" m^2/s\n\n")
        print("\nStandard deviation: "+"%.4e" % std  +" m^2/s\n\n")
        print("\nMean Diffusion (Bootstrap): "+"%.4e" % res_sum_2  +" m^2/s\n\n")
        print("\nStandard deviation (Bootstrap): "+"%.4e" % std_2  +" m^2/s\n\n")

    # Set data frame for the used lag times
    data = [str("%.2e" % D_mean[i]) + " $\mathrm{m^2s^{-1}}$" for i in range(len(len_step))]
    diff_table = pd.DataFrame(data,index=list(len_step),columns=list(['$D_\mathrm{mean}$']))
    diff_table = pd.DataFrame(diff_table.rename_axis('Step Length', axis=1))
    styler = diff_table.style.set_caption('Selected step length')
    diff_table =styler.set_properties(**{'text-align': 'right'})
    diff_table = diff_table.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])

    # Set vectors for plotting
    D_mean_vec = [D_mean[i] * 10 ** 9 for i in range(len(lagtime_inverse))]
    lag_time_vec = [ 1 / (len_step[i] * dt) for i in range(len(len_step))]
    x_vec = x = np.arange(0, max(lag_time_vec) * 2, (max(lag_time_vec) * 2) / 5 )

    # fit a linear line
    fit = np.poly1d(np.polyfit(lag_time_vec,D_mean_vec,1))

    # Plot the results
    plt.xlim(0,1.5*max(lag_time_vec))
    plt.ylim(0,1.5*max(fit(x_vec)))
    sns.scatterplot(x=lag_time_vec, y=D_mean_vec,color ='red')
    sns.lineplot(x=x_vec, y=fit(x_vec))
    legend = ["$D_{\mathrm{fit}}$","$D_{\mathrm{mean}}(\Delta_{ij}t_{\\alpha})$"]
    plt.legend(legend)
    plt.xlabel(r"Inverse lag time ($10^{12} \ \mathrm{s^{-1}})$")
    plt.ylabel(r"Diff. coeff. ($10^{-9} \ \mathrm{m^2s^{-1}}$)")

    return fit(0) * 10**-9,diff_table

def diff_profile(link,len_step=[], infty_profile = True):
    """
    This function plots the diffusion profile over the box for the calculated lagtimes.

    Parameters
    ----------
    link : string
        link to the diffusion data object generated by the :func:`do_mc_cycles`
    len_step : integer list, optional (default = None)
        list of the different step length, if it is None the lag times which are contains in the obj file are printed
    infty_profile : bool (default = True)
        if its True only the profile for an infity lagtime is plotted
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_profile"]
    df_bin = results["df_profile"]
    inp = results["model"]
    diff_unit = inp["diffusion unit"]
    dt = inp["len_frame"]
    bins = inp["bins"]
    bins = [(bins[i] + (bins[1]-bins[0])) for i in range(len(bins))]
    legend = []

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
            len_step = inp["len_step"]

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]   # Inverse lagtime in s

    # Calculate diffusion profiles
    diff_profiles = [[np.exp(diff_bin[i][j] + diff_unit) * 10**3 for j in range(len(bins))] for i in len_step ]

    # If infty_profile is false the profiles for the different lag times are plotted
    if infty_profile == False:
        # Plot the profiles for the
        for i in range(len(len_step)):
            sns.lineplot(x=bins, y=(diff_profiles[i]))       # Diffusion in m^2/s

        # Plot the diffusion profiles for the different lag times
        legend = ["lag time " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

    # If infty_profile is True the diffusion profile for a infinity lag times is shwon
    if len(len_step)>=2 and infty_profile == True:

        # Initialize fit vector
        diff_profile_fit = []

        # Calculate the mean diffusion over all bins
        for i in range(len(bins)):
            diff = [np.exp(diff_bin[step][i] + diff_unit) * 10**-6 for step in len_step]   # Diffusion in m^2/s

            # fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse,diff,1))

            #Append diffusion at t-> infty
            diff_profile_fit.append(fit(0)*10**9)

        # Plot fitted diffusion profile
        sns.lineplot(x=bins, y = diff_profile_fit )       # Diffusion in m^2/s

    # Set legend for lag times
    if infty_profile == False:
        # Add legend
        legend.append("Lagtime $\\infty$ ps")
        plt.legend(legend)

    # Set plot properties
    plt.xlabel(r"Box length (nm)")
    plt.ylabel(r"Diffusion ($10^{-9} \ \mathrm{m^2s^{-1}}$)")


##################
# Pore Diffusion #
##################
def diffusion_pore(link_pore, link, len_step=[], is_std=True):
    """
    This function uses the diffusion profiles over box length which are calculated in the function :func:`do_mc_cycles` to estimate the final diffusion coefficient into a pore. For that a line is fitted of the averaged diffusion profiles :math:`D_{mean}({\\Delta_{ij}t_{alpha}})` in the pore area for the different lag times as a function of :math:`1/\\Delta_{ij}t_{alpha}`. The function plots all mean diffusion :math:`D_{mean}({\\Delta_{ij}t_{alpha}})` over the inverse lag times and the linear fit. Additional the final mean diffusion coefficient :math:`D` for a lagtime :math:`\\Delta_{ij}t_{alpha} \\rightarrow \infty` is printed. Also a table of the selected step length and the belonging :math:`D_{mean}({\\Delta_{ij}t_{alpha}})` can be displayed.

    In order to be able to estimate how the choice of lag times affects the result, an additional error estimation is possible. For this all possible fourth tuples of the entire calculated lag times are used to estimate a mean diffusion coefficient :math:`\\langle D \\rangle` which is the mean value of all fourth tuples fitting results. Also the standard deviation of all fitting results is printed. If there is no big difference between the diffusion coefficient :math:`D` and the mean diffusion ceofficient :math:`\\langle D \\rangle`, all :math:`D_{mean}({\\Delta_{ij}t_{alpha}})` are on a straight line. The standard deviation can also be used to check if the result fluctuates strongly at the choice of other lag times. This error estimate is calculated if :math:`is_std=True`.

    Parameters
    ----------
    link_pore : string
        Link to poresystem object file
    link: string
        link to the diffusion data object file generated with the function :func:`do_mc_cycles`
    len_step: integer list, optional (default = [])
        list of the different step length, if it is [] the lag times which are contains in the obj file are printed
    is_std : bool (default=True)
        if it is true a mean diffusion coefficient and a Bootstrap diffusion is calculated to be able to assess the dependency of the results on the chosen lag time

    Returns
    -------
    diffusion: float
        diffusion coefficient :math:`D \ (\\frac{m^2}{s})` into the pore
    diff_table : obj
        table of used lag times for fitting of :math:`D \ (\\frac{m^2}{s})`
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_profile"]
    df_bin = results["df_profile"]
    inp = results["model"]
    bins = inp["bins"]
    diff_unit = inp["diffusion unit"]
    dt = inp["len_frame"]
    bins = [(bins[i] + (bins[1]-bins[0]))   for i in range(len(bins))]
    diff_bin_pore = {}
    diff = np.zeros(len(bins))

    # Load pore obj file
    pore = utils.load(link_pore)
    res = pore.reservoir()
    box = pore.box()

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
        len_step = inp["len_step"]

    # Cut profile (chose only the pore area for fitting)
    # Calculated start and end bin index of the pore area
    index_start = np.digitize(res,bins)
    index_end  = np.digitize((res + box[2]), bins)

    #Save for all lag times the cutted profile
    for i in len_step:
            diff_bin_pore[i] = {}
            diff = diff_bin[i]
            diff_bin_pore[i] = diff[index_start:index_end]

    # Calculate the mean diffusion over all bins
    D_mean = [np.mean(np.exp(diff_bin_pore[i] + diff_unit)) * 10**3 for i in len_step]   # Diffusion in m^2/s

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt) for i in range(len(len_step))]   # Inverse lagtime in s

    # Plot the diffusion profiles for the different lag times
    legend = ["lagtime " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

    # fit a linear line
    fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

    # set the x value for the linear fit
    x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5 )

    # Calculate the diffusion coefficient as a mean value over the bin
    print("\nDiffusion: "+"%.4e" % fit(0)  +" m^2/s\n\n")

    # If is_std true print the results of the calculations
    if is_std:
        len_step_all = len_step

        # Determine all possible combinations
        a = list(itertools.combinations(len_step_all,2))

        # Allocate the results vector
        res = np.zeros(len(a))

        # Fit for all combinations
        for i in range(len(a)):

            # set the current tuple
            rand = list(a[i])

            # Calculate the mean diffusion over all bins
            D_mean = [np.mean(np.exp(diff_bin_pore[i] + diff_unit)) * 10**-6 for i in rand]  # Diffusion in m^2/s

            # Calculate the inverse lag time for the linear fit
            lagtime_inverse = [ 1 / (i * dt * 10**-12) for i in rand]   # Inverse lagtime in s

            # fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

            # set the x value for the linear fit
            x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5 )

            # Set the fitted diffusion coefficient on the results list
            res[i] = fit(0)

        # Determine standard deviation and mean diffusion of fourth touple method
        res_sum = np.mean(res)
        std = res.std()

        # Print results
        print("\nMean Diffusion: "+"%.4e" % res_sum  +" m^2/s\n\n")
        print("\nStandard deviation: "+"%.4e" % std  +" m^2/s\n\n")

    # Set data frame for the used lag times
    data = [str("%.4e" % D_mean[i]) + " $\mathrm{m^2s^{-1}}$" for i in range(len(len_step))]
    diff_table = pd.DataFrame(data,index=list(len_step),columns=list(['$D_\mathrm{mean}$']))
    diff_table = pd.DataFrame(diff_table.rename_axis('Step Length', axis=1))
    styler = diff_table.style.set_caption('Selected step length')
    diff_table =styler.set_properties(**{'text-align': 'right'})
    diff_table = diff_table.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])

    # Plot the results
    plt.xlim(0,1.5*max(lagtime_inverse))
    plt.ylim(0,1.5*max(fit(x)))
    sns.scatterplot(x=lagtime_inverse, y=D_mean,color ='red')
    sns.scatterplot(x=[0.0], y=[fit(0)],color ='black')
    sns.lineplot(x=x, y=fit(x))
    legend = ["$D_{\mathrm{fit}}$","$D_{\mathrm{mean}}(\Delta_{ij}t_{\\alpha})$"]
    plt.legend(legend)
    plt.xlabel(r"Inverse lagtime ($10^{12} \ \mathrm{s^{-1}})$")
    plt.ylabel(r"Diff. coeff. ($10^{-9} \ \mathrm{m^2s^{-1}}$)")

    return fit(0),diff_table

def diff_pore_profile(link_pore, link, len_step=[], infty_profile = False):
    """
    This function plots the diffusion profile in the pore over pore length for the calculated lagtimes.

    Parameters
    ----------
    link_pore : string
        Link to poresystem object file
    link : string
        link to the diffusion data object generated by the :func:`do_mc_cycles`
    len_step: integer list, optional (default = [])
        list of the different step length, if it is None the lag times which are contains in the obj file are printed
    infty_profile : bool (default = False)
        if its True only the profile for an infity lagtime is plotted
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_profile"]
    df_bin = results["df_profile"]
    inp = results["model"]
    bins = inp["bins"]
    diff_unit = inp["diffusion unit"]
    dt = inp["len_frame"]
    bins = [(bins[i] + (bins[1]-bins[0]))   for i in range(len(bins))]
    diff_bin_pore = {}
    diff = np.zeros(len(bins))
    # Load pore obj file
    pore = utils.load(link_pore)
    res = pore.reservoir()
    box = pore.box()
    legend = []

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
        len_step = inp["len_step"]

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]   # Inverse lagtime in s

    # Cut profile (chose only the pore area)
    # Calculated start and end bin index of the pore area
    index_start = np.digitize(res,bins)
    index_end  = np.digitize((res + box[2]), bins)

    #Save for all lag times the cutted profile
    for i in len_step:
            diff_bin_pore[i] = {}
            diff = diff_bin[i]
            diff_bin_pore[i] = diff[index_start:index_end]

    # List with the bins in the pore
    bins_pore = [bins[i] - res for i in range(index_start,index_end)]

    # Determine diffusion profile in the pore area
    diff_bin_pore = [[np.exp(diff_bin_pore[j][i] + diff_unit) * 10 ** 3 for i in range(len(bins_pore))] for j in len_step]

    # If infty_profile is false the profiles for the different lag times are plotted
    if infty_profile == False:
        # Plot the diffusion profiles for the different lag times
        legend = ["lag time " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

        # Plot the profiles for the
        for i in range(len(len_step)):
            sns.lineplot(x=(bins_pore), y=diff_bin_pore[i])       # Diffusion in m^2/s


    # If infty_profile is True the diffusion profile for a infinity lag times is shwon
    if len(len_step)>=2 and infty_profile == True:
        # Initialize fit vector
        diff_profile_fit = []

        # Calculate the mean diffusion over all bins
        for i in range(len(bins_pore)):
            diff = [diff_bin_pore[step][i] for step in range(len(len_step))]   # Diffusion in m^2/s

            # fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse,diff,1))

            #Append diffusion at t-> infty
            diff_profile_fit.append(fit(0))

        # Plot fitted diffusion profile
        sns.lineplot(x=(bins_pore), y = diff_profile_fit)       # Diffusion in m^2/s

    # Set legend for lag times
    if infty_profile == False:
        # Add legend
        legend.append("Lagtime $\\infty$ ps")
        plt.legend(legend)

    # Set plot properties
    plt.xlabel(r"Pore length (nm)")
    plt.ylabel(r"Diffusion ($\mathrm{m^2s^{-1}}$)")

###############
# Free Energy #
###############
def df_profile(link,len_step=[]):
    """
    This function plots the free energy profile over the box for the calculated lag times. In contrast to the diffusion profile the diffusion profile has not a dependency on the lag time. If the free energy profiles are not close to equal the calculation is incorrect.

    Parameters
    ----------
    link : string
        link to the diffusion data object generated by the :func:`do_mc_cycles`
    len_step: integer list, optional (default = [])
        list of the different step length, if it is None the lag times which are contains in the obj file are printed
    """

    # Load Results from the output object file
    results = utils.load(link)
    df_bin = results["df_profile"]
    inp = results["model"]
    dt = inp["len_frame"]
    bins = inp["bins"]

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
        len_step = inp["len_step"]

    # Set legend
    legend = ["lagtime " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

    # Plot the free energy profiles
    for i in len_step:
         sns.lineplot(x=bins, y=(df_bin[i]))

    # Plot options
    plt.xlabel(r"Box length (nm)")
    plt.ylabel(r"Free energy ($\mathrm{J^{-1}}$)")
    plt.legend(legend)


#################
# Pandas Tables #
#################
def print_statistics_mc(link_out, print_con=False):
    """
    This function prints the statistic of the MC Run for every lag time.

    Parameters
    ----------
    link_out: string
        link to the diffusion data object generated by the sample routine :func:`moldyn.pores.mcdiff.mc.do_mc_cycles`

    Returns
    -------
    df_results: obj
        data frame of the MC Alogrithm statistics
    print_con: bool (default = False)
        if its true the table can be print in console
    """

    # If a data object output as an input take the results
    results = utils.load(link_out)
    model = results["model"]
    len_step = model["len_step"]
    inp = results["inp"]
    nmc_eq = inp["MC steps eq"]
    nmc = inp["MC steps"]
    nmc_radial_eq = inp["MC steps radial eq"]
    nmc_radial = inp["MC steps radial"]
    num_mc_update = inp["step width update"]
    print_freq = inp["print freq"]

    #Read MC statistic
    nacc_df_mean = results["nacc_df"]
    nacc_diff_mean = results["nacc_diff"]
    nacc_diff_radial_mean = results["nacc_diff_radial"]
    list_diff_fluc = results["fluc_diff"]
    list_df_fluc = results["fluc_df"]
    list_diff_radial_fluc = results["fluc_diff_radial"]


    # Table for MC Statistics
    data = [[str("%.4e" % list_df_fluc[i]) for i in len_step],[str("%.4e" % list_diff_fluc[i]) for i in len_step],[str("%.4e" % list_diff_radial_fluc[i]) for i in len_step],[str("%.0f" % nacc_df_mean[i]) for i in len_step],[str("%.0f" % nacc_diff_mean[i]) for i in len_step],[str("%.0f" % nacc_diff_radial_mean[i]) for i in len_step],[str("%.2f" % (nacc_df_mean[i]*100/(nmc+nmc_eq))) for i in len_step],[str("%.2f" % (nacc_diff_mean[i]*100/(nmc+nmc_eq))) for i in len_step],[str("%.2f" % float(nacc_diff_radial_mean[i]*100/(nmc_radial+nmc_radial_eq))) for i in len_step]]

    # Set index of panda table
    df_results = pd.DataFrame(data,index=list(['fluctuation df','fluctuation diff','fluctuation rad. diff','acc df steps','acc diff steps','acc rad. diff steps','acc df steps (%)','acc diff steps (%)','acc rad. diff steps (%)']),columns=list(len_step))

    # If the table has to print in console
    if print_con==True:
        print('\nStatistics of the MC Algorithm')
        print(df_results)

    # Set styler for pandas table in jupyter
    df_results = pd.DataFrame(df_results.rename_axis('Step Length', axis=1))
    styler = df_results.style.set_caption('Statistics of the MC Algorithm')
    df_results = styler.set_properties(**{'text-align': 'right'})
    df_results = df_results.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])

    return df_results


def print_coeff(link_out, print_con=False):
    """
    This function prints the final coefficients of the profile for every lag time profile.

    Parameters
    ----------
    link_out: string
        link to the diffusion  data object generated by the sample routine :func:`poreana.post_process.do_mc_cycles`

    Returns
    -------
    df_results: obj
        data frame of the MC Alogrithm statistics
    print_con: bool (default = False)
        if its true the table can be print in console
    """

    # If a data object output as an input take the results
    results = utils.load(link_out)
    model = results["model"]
    len_step = model["len_step"]
    diff_coeff = results["list_diff_coeff"]
    df_coeff = results["list_df_coeff"]
    nD = model["nD"]
    nF = model["nF"]

    # Initialize data dictionary for the diffusion profile coefficients
    data = {}

    # Save diffusion profile coefficients on data dictionary
    for i in len_step:
        data[i] = [str("%.4e" % diff_coeff[i][j]) for j in range(nD)]

    # Pandas table
    diff_coeff = pd.DataFrame(data,index=list(np.arange(1,nD+1)),columns=list(len_step))
    diff_coeff = pd.DataFrame(diff_coeff.rename_axis('Step Length', axis=1))

    # If the table has to print in console
    if print_con==True:
        print('\nDiffusion coefficients')
        print(diff_coeff)

    # Set styler for pandas table in jupyter
    styler = diff_coeff.style.set_caption('Diffusion coefficients')
    diff_coeff = styler.set_properties(**{'text-align': 'right'})
    diff_coeff = diff_coeff.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])


    # Initialize data dictionary for the diffusion profile coefficients
    data = {}

    # Save free energy profile coefficients on data dictionary
    for i in len_step:
        data[i] = [str("%.4e" % df_coeff[i][j]) for j in range(nF)]

    # Pandas table
    df_coeff = pd.DataFrame(data,index=list(np.arange(1,nF+1)),columns=list(len_step))
    df_coeff = pd.DataFrame(df_coeff.rename_axis('Step Length', axis=1))

    # If the table has to print in console and not in a jupyter notebook
    if print_con==True:
        print('\nFree energy coefficients')
        print(df_coeff)

    # Set styler for pandas table in jupyter
    styler = df_coeff.style.set_caption('Free energy coefficients')
    df_coeff = styler.set_properties(**{'text-align': 'right'})
    df_coeff = df_coeff.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])

    return diff_coeff, df_coeff


def print_model_inputs(link_out, print_con=False):
    """
    This function prints the model inputs of the calculation.

    Parameters
    ----------
    link_out: string
        link to the diffusion data object generated by the sample routine :func:`moldyn.pores.mcdiff.mc.do_mc_cycles`

    Returns
    -------
    df_model: obj
        data frame of the model inputs
    print_con: bool (default = False)
        if its true the table can be print in console
    """
    # Read model inputs
    results = utils.load(link_out)
    model = results["model"]
    bin_number = model["bin number"]
    rad_bin_number = model["radial bin number"]
    len_step = model["len_step"]
    len_frame = model["len_frame"]
    frame_num = model["frame_num"]
    nD = model["nD"]
    nF = model["nF"]
    nDrad = model["nDrad"]
    system = model["system"]
    d = model["guess"]
    mol_num = model["mol num"]
    mol_name = model["mol name"]
    model = model["model"]

    # String which contains all lag times
    len_step_string = ', '.join(str(step) for step in len_step)

    # dictionary for model inputs
    data = [str("%.f" % bin_number),str("%.f" % rad_bin_number),len_step_string,str("%.2e" % (len_frame * 10**(-12))), mol_name, str("%.f" % (mol_num)),str("%.f" % frame_num),str("%.f" % nD),str("%.f" % nF),str("%.f" %nDrad),system,model,str("%.2e" % (d * 10**(-6)))]
    df_model = pd.DataFrame(data,index=list(['Bin number','Radial bin number','step length','frame length (s)','mol name', 'mol num', 'frame number','nD','nF','nDrad','system','model','guess diffusion (m2/s-1)']),columns=list(['Input']))

    # If the table has to print in console and not in a jupyter notebook
    if print_con==True:
        print('\nModel Inputs')
        print(df_model)

    # Set styler for pandas table in jupyter
    styler = df_model.style.set_caption('Model Inputs')
    df_model = styler.set_properties(**{'text-align': 'right'})
    df_model = df_model.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])

    return df_model

def print_mc_inputs(link_out, print_con=False):
    """
    This function prints the MC Algorithm inputs of the calculation.

    Parameters
    ----------
    link_out: string
        link to the diffusion data object generated by the sample routine :func:`moldyn.pores.mcdiff.mc.do_mc_cycles`

    Returns
    -------
    df_mc: obj
        data frame of the MC Alogrithm inputs
    print_con: bool (default = False)
        if its true the table can be print in console
    """

    # Load Results from the output object file
    results = utils.load(link_out)

    # Read MC inputs
    inp = results["inp"]
    nmc_eq = inp["MC steps eq"]
    nmc = inp["MC steps"]
    nmc_radial_eq = inp["MC steps radial eq"]
    nmc_radial = inp["MC steps radial"]
    num_mc_update = inp["step width update"]
    print_freq = inp["print freq"]

    # Table for MC Inputs
    data = [nmc_eq,nmc,nmc_radial_eq,nmc_radial,num_mc_update,print_freq]
    df_mc = pd.DataFrame(data,index=list(['MC steps (Equilibrium)','MC steps (Production)','radial MC steps (Equilibrium)','radial MC step (Production)','movewidth update frequency','print frequency']),columns=list(['Input']))

    # If the table has to print in console and not in a jupyter notebook
    if print_con==True:
        print('\nMC Inputs')
        print(df_mc)

    # Set style for the pandas table
    styler = df_mc.style.set_caption('MC Inputs')
    df_mc = styler.set_properties(**{'text-align': 'right'})
    df_mc = df_mc.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])

    return df_mc


##########################
# Plor transition matrix #
##########################
def plot_trans_mat(link_in,step,kwargs={}):
    """
    This function plots the occupation of a normalized transition matrix as an heatmap. To normalize the matrix the number of the frame are used.

    Parameters
    ----------
    link_in: string
        link to the diffusion sample obj file generated by the sample routine :func:`moldyn.pores.sample`
    step: int
        step length for the trans matrix to be visualized
    kwargs: dict
        dictionary with heatmap parameters to adjust the transition heatmap
    """

    # Load Results from the output object file
    results = utils.load(link_in)
    model = results["model"]
    trans_mat = model["data"]
    frame_num = model["num_frame"]
    frame_length = model["len_frame"]

    # Set title for the lag time
    plt.title("Lagtime: "+str(step * frame_length) + " ps", fontsize=10)

    # Plot the normalized transition matrix in a heat map
    # Without options for the heatmap plots
    if not kwargs:
        sns.heatmap(trans_mat[step]/frame_num)

    # With options for the heatmap plots
    else:
        sns.heatmap(trans_mat[step]/frame_num, **kwargs)


####################
# Radial Diffusion #
####################
def diffusion_radial(link, len_step=None):
    """
    This function use the diffusion profiles over the bins from the function :func:`do_mc_cycles` to caluclate the final diffusion coefficient. For that a line is fit of the mean diffusion :math:`D_{mean}({\\Delta_{ij}t_{alpha}})` for the different lagtimes as a function of :math:`1/\\Delta_{ij}t_{alpha}` . The function plot all mean diffusion :math:`D_{mean}({\\Delta_{ij}t_{alpha}})` over all inverse input lagtimes and the linear fit. Additional the final mean diffusion coefficient :math:`D` for a lagtime :math:`\\Delta_{ij}t_{alpha} \\rightarrow \infty` is printed. Also a table of the selected step length and the belonging :math:`D_{mean}({\\Delta_{ij}t_{alpha}})` and the :math:`D_{avg}({\\Delta_{ij}t_{alpha}})` can be displayed

    Formel f√ºr avg falls das drin bleibt

    Parameters
    ----------
    link: string
        link to the diffusion data object generated by the sample routine :func: `sample_box`
    len_step: integer list, optional (default = None)
        list of the different step length, if it is None the lag times which are contains in the obj file are printed

    Returns
    -------
    diffusion: float
        diffusion coefficient :math:`D \ (\\frac{m^2}{s})` for the calculated system
    diff_table : obj
        table of used lag times for fitting of :math:`D \ (\\frac{m^2}{s})`
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_radial_profile"]
    df_bin = results["df_profile"]
    inp = results["model"]
    bins = inp["bins"]
    diff_unit = inp["diffusion radial unit"]
    dt = inp["len_frame"]

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
        len_step = inp["len_step"]

    # Calculate the mean diffusion over all bins
    D_mean = [np.mean(np.exp(diff_bin[i] + diff_unit)) * 10**-6 for i in len_step]   # Diffusion in m^2/s

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]   # Inverse lagtime in s

    # fit a linear line
    fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

    # set the x value for the linear fit
    x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5 )


    # Calculate the diffusion coefficient as a mean value over the bin
    print("\nMean Radial Diffusion: "+"%.4e" % fit(0)  +" m^2/s\n")

    # Integration
    bin_width = bins[1]-bins[0]

    # Determine averaged diffusion weight with the free energy profile
    diff_avg = [(np.trapz(np.exp(df_bin[i])*np.exp(diff_bin[i] + diff_unit), bins, bin_width) / np.trapz(np.exp(df_bin[i]), bins, bin_width)) * 10**-6 for i in len_step]

    # Set data frame for the used lag times
    D_mean_pd = [str("%.2e" % D_mean[i]) for i in range(len(D_mean))]
    diff_avg_pd = [str("%.2e" % diff_avg[i]) for i in range(len(diff_avg))]
    diff_table = pd.DataFrame({'$D_\mathrm{mean}$':D_mean_pd,'$D_\mathrm{avg} (\mathrm{m^2s^{-1}})$': diff_avg_pd},index=list(len_step))
    diff_table = pd.DataFrame(diff_table.rename_axis('Step Length', axis=1))
    styler = diff_table.style.set_caption('Selected step length')
    diff_table =styler.set_properties(**{'text-align': 'right'})
    diff_table = diff_table.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])


    # Plot the results
    plt.xlim(0,1.5*max(lagtime_inverse))
    plt.ylim(0,1.5*max(fit(x)))
    sns.scatterplot(x=lagtime_inverse, y=D_mean,color ='red')
    sns.lineplot(x=x, y=fit(x))
    legend = ["linear fit","$D_{\mathrm{mean}}$"]
    plt.legend(legend)
    plt.xlabel(r"Inverse lagtime ($\mathrm{s^{-1}})$")
    plt.ylabel(r"radial Diff. coeff. ($\mathrm{m^2s^{-1}}$)")

    return fit(0),diff_table


def diff_radial_profile(link,len_step=None,avg=False):
    """
    This function plots the radial diffusion profile over the box for serveral lagtimes.

    Parameters
    ----------
    link : string
        link to the diffusion data object generated by the :func:`do_mc_cycles`
    len_step: integer list, optional (default = None)
        list of the different step length, if it is None the lag times which are contains in the obj file are printed
    avg: bool
        if its True a averaged profile of all selected lagtimes is plotted too

    Returns
    -------
    diffusion: float
        diffusion coefficient :math:`D \ (\\frac{m^2}{s})` for the calculated system
    diff_table : obj
        table of used lag times for fitting of :math:`D \ (\\frac{m^2}{s})`
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_radial_profile"]
    inp = results["model"]
    dt = inp["len_frame"]
    diff_unit = inp["diffusion radial unit"]
    bins = inp["bins"]
    bins = [(bins[i]) * 10**-8   for i in range(len(bins))]

    if len_step is None:
        len_step = inp["len_step"]

    # Plot the diffusion profiles for the different lag times
    legend = ["lagtime " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

    # Plot the profiles for the
    for i in len_step:
        sns.lineplot(x=bins, y=np.exp(diff_bin[i] + diff_unit) * 10**-6)       # Diffusion in m^2/s


    # Averged profile over the selected lag times
    if len(len_step) != 1 and avg==True:
        diff_mean = np.zeros(len(bins[:-1]))
        diff = []
        for i in len_step:
            diff_mean += diff_bin[i]
        diff = [diff_mean[i]/len(len_step) for i in range(len(diff_mean))]

        # Plot mean profile over the selected lag times
        sns.lineplot(x=bins, y=np.exp(diff + diff_unit) * 10**-6)       # Diffusion in m^2/s
        legend.append("avg profile")

    # Set plot properties
    plt.xlabel(r"Box length (m)")
    plt.ylabel(r"radial Diffusion ($\mathrm{m^2s^{-1}}$)")
    plt.legend(legend)
