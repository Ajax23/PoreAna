################################################################################
# Density                                                                      #
#                                                                              #
"""Analyse density in a pore."""
################################################################################


import math
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

import poreana.utils as utils


def bins(link_data, area=[[10, 90], [10, 90]], target_dens=0, is_print=True):
    """This function calculates the density inside and outside of the pore.
    This is done by calculating the number density :math:`\\rho_n` and using the
    molar mass :math:`M` of the molecule to determine the mass density
    :math:`\\rho`.

    The basic idea is counting the number of molecules :math:`N_i` in volume
    slices :math:`V_i`, thus getting the number density :math:`\\rho_{n,i}` in
    these sub volumes. Inside the pore this is done by creating a radial slicing
    like the radial distribution function. These sub volumes are calculated by

    .. math::

        V_i^\\text{radial}=\\pi z_\\text{pore}(r_i^2-r_{i-1}^2).

    with pore length :math:`z_\\text{pore}` and radius :math:`r_i` of sub volume
    :math:`i`. This yields

    .. math::

        \\rho_{n,i}^\\text{radial}=\\frac{N_i}{V_i^\\text{radial}}=\\frac{N_i}{\\pi z_\\text{pore}}\\frac{1}{r_i^2-r_{i-1}^2}.

    Outside the pore, the sub volumes are given by

    .. math::

        V_j^\\text{ex}=(x_\\text{pore}\\cdot y_\\text{pore}-\\pi r^2)z_j

    with pore width :math:`x_\\text{pore}`, height :math:`y_\\text{pore}`, pore
    radius :math:`r` and slice width :math:`z_j`. Thus

    .. math::

        \\rho_{n,j}^\\text{ex}=\\frac{N_j}{V_j^\\text{ex}}=\\frac{N_j}{x_\\text{pore}\\cdot y_\\text{pore}-\\pi r^2}\\frac{1}{z_j}.

    Note that the outside refers to the reservoirs of the pore simulation.
    Therefore the slices add up to the reservoir length :math:`z_{res}`.
    Since there is a reservoir on each side, they are brought together
    by translating the atom coordinates to one of the reservoirs. Since the
    outside density refers to the density of the outside surface, it does
    not contain the cylindrical extension of the pore inside the reservoirs.

    Finally, the mass density is calculated by

    .. math::

        \\rho=\\frac M{N_A}\\rho_n

    with Avogadro constant :math:`N_A`. The units are then transformed to
    :math:`\\frac{\\text{kg}}{\\text m^3}` by

    .. math::

        [\\rho]=\\frac{[M]\\frac{\\text{g}}{\\text{mol}}}{[N_A]10^{23}\\frac{\\#}{\\text{mol}}}[\\rho_n]\\frac{\\#}{\\text{nm}^3}
               =\\frac{[M]}{[N_A]}[\\rho_n]\\cdot10\\frac{\\text{kg}}{\\text m^3}

    where the square brackets mean, that only the variables value is taken.
    Since finding full molecules in a sub volume is difficult, the atoms
    of the specified molecule are counted in the sub volumes and the result
    is then divided by the number of atoms the molecule consists of.

    Parameters
    ----------
    link_data : string
        Link to hdf5, obj or yml data file generated by the sample routine :func:`poreana.sample.Sample.init_density`
    area : list,  optional
        Bin areas to calculate the mean number density from (pore, exout)
    target_dens : float, optional
        Target density in :math:`\\frac{\\text{kg}}{\\text{m}^3}`
    is_print : bool, optional
        True to print output

    Returns
    -------
    density : dictionary
        dictonary with inputs and the calculated density profiles and mean
        density
    """
    # Load data object
    sample = utils.load(link_data)
    is_pore = "pore" in sample

    # Load bins
    bins = {}
    for pore_id in sample["data"].keys():
        if pore_id[:5]=="shape":
            bins[pore_id] = {}
            bins[pore_id]["in"] = sample["data"][pore_id]["in"] if is_pore else []
    bins["ex"] = sample["data"]["ex"]

    # Load width
    width = {}
    for pore_id in sample["data"].keys():
        if pore_id[:5]=="shape":
            width[pore_id] = {}
            width[pore_id]["in"] = sample["data"][pore_id]["in_width"] if is_pore else []
    width["ex"] = sample["data"]["ex_width"]

    # Load input data
    inp = sample["inp"]
    bin_num = int(inp["bin_num"])
    num_frame = inp["num_frame"]
    entry = inp["entry"]
    mass = inp["mass"]
    remove_pore_from_res = inp["remove_pore_from_res"]

    # Load pore data
    pore_props = {}
    if is_pore:
        for pore_id in sample["data"].keys():     
            if pore_id[:5]=="shape":
                pore_props[pore_id] = {}
                pore = sample["pore"]
                pore_props[pore_id]["pore_type"] = pore[pore_id]["type"]
                pore_props[pore_id]["diam"] = pore[pore_id]["diam"]
                pore_props[pore_id]["length"] = pore[pore_id]["length"]
        box = pore["box"]["dimensions"]
        res = pore["box"]["res"]

    else:
        box = sample["box"]["length"]

    # Calculate bin volume
    volume = {}

    ## Interior
    if is_pore:
        for pore_id in pore_props.keys():     
            volume[pore_id] = {}
            if pore_props[pore_id]["pore_type"] in ["CYLINDER","CONE"]:
                volume[pore_id]["in"] = [math.pi*(pore_props[pore_id]["length"]-2*entry)*(width[pore_id]["in"][i+1]**2-width[pore_id]["in"][i]**2) for i in range(0, bin_num+1)]
            elif pore_props[pore_id]["pore_type"]=="SLIT" and inp["avg_slit"]:
                volume[pore_id]["in"] = [box[0]*(box[2]-2*res-2*entry)*(width[pore_id]["in"][i+1]-width[pore_id]["in"][i])*2 for i in range(0, bin_num+1)]
            elif pore_props[pore_id]["pore_type"]=="SLIT" and not inp["avg_slit"]:
                volume[pore_id]["in"] = [box[0]*(box[2]-2*res-2*entry)*(width[pore_id]["in"][i+1]-width[pore_id]["in"][i]) for i in range(0, bin_num+1)]

            ## Exterior  ###Update fehlt hier noch 
            if remove_pore_from_res and pore_props[pore_id]["pore_type"] in ["CYLINDER","CONE"]:
                volume["ex"] = [2*width["ex"][1]*(box[0]*box[1]-math.pi*(pore_props[pore_id]["diam"]/2)**2) for i in range(bin_num+1)]
            elif remove_pore_from_res and pore_props[pore_id]["pore_type"]=="SLIT":
                volume["ex"] = [2*width["ex"][1]*box[0]*(box[1]-pore_props[pore_id]["diam"]) for i in range(bin_num+1)]
            else:
                volume["ex"] = [2*width["ex"][1]*box[0]*box[1] for i in range(bin_num+1)]
    else:
        # For calculating density over one box length
        try:
            direction = inp["direction"]
            directions = [i for i in range(3) if i!= direction]
            surface = box[directions[0]]*box[directions[1]]
        # Except to ensure compliance with older calculations 
        except:
            surface = box[0]*box[1]
        volume["ex"] = [width["ex"][1]*surface for i in range(bin_num+1)]

    # Calculate the number density
    num_dens = {}
    for pore_id in pore_props.keys(): 
        num_dens[pore_id] = {}
        num_dens[pore_id]["in"] = [bins[pore_id]["in"][i]/volume[pore_id]["in"][i]/num_frame for i in range(bin_num+1)] if is_pore else []
    num_dens["ex"] = [bins["ex"][i]/volume["ex"][i]/num_frame for i in range(bin_num+1)]

    # Calculate the mean in the selected area
    mean = {}
    for pore_id in pore_props.keys(): 
        mean[pore_id] = {}
        mean[pore_id]["in"] = np.mean(num_dens[pore_id]["in"][area[0][0]:area[0][1]]) if is_pore else []
    mean["ex"] = np.mean(num_dens["ex"][area[1][0]:area[1][1]])

    # Calculate Density
    dens = {}
    for pore_id in pore_props.keys(): 
        dens[pore_id] = {}
        dens[pore_id]["in"] = mass*10/6.022*mean[pore_id]["in"] if is_pore else []
    dens["ex"] = mass*10/6.022*mean["ex"]

    # Calculate difference to target density
    if is_pore:
        num_diff = (target_dens/mass/10*6.022-mean["ex"])*box[0]*box[1]*res*2 if target_dens else 0
    else: 
        num_diff = (target_dens/mass/10*6.022-mean["ex"])*box[0]*box[1]*box[2]*2 if target_dens else 0

    # Output
    if is_print:
        if is_pore:
            for pore_id in pore_props.keys(): 
                print("Density inside " +  pore_id + " = "+"%5.3f"%mean[pore_id]["in"]+" #/nm^3 ; "+"%7.3f"%dens[pore_id]["in"]+" kg/m^3")
            print("Density outside Pore Area = "+"%5.3f"%mean["ex"]+" #/nm^3 ; "+"%7.3f"%dens["ex"]+" kg/m^3")
        else:
            print("Density = "+"%5.3f"%mean["ex"]+" #/nm^3 ; "+"%7.3f"%dens["ex"]+" kg/m^3")
        if target_dens:
            print("Density difference   = "+"%5.3f" % (target_dens-dens["ex"])+" kg/m^3 ; "
                  +"%4.2f" % ((1-dens["ex"]/target_dens)*100)+" % ; "
                  +"%3i" % num_diff+" #")

    # Return output
    return  {"sample": sample, "num_dens": num_dens, "mean": mean, "dens": dens, "diff": num_diff}


def bins_plot(density, pore_id="shape_00", intent="", target_dens=0, is_mean=False, kwargs={}):
    """This function plots the density of the given object. If an intent is
    given instead, only a plot-function will be called. Available options
    for ``intent`` are

    * empty string - Create subplots for the density inside and outside the pore
    * **in** - Create plot for the density inside pore
    * **ex** - Create plot for the density outside pore

    Parameters
    ----------
    density : dictionary
        Density object from the density calculation :func:`bins`
    pore_id : string, optional
        If there is more than one shape in the structure, select the shape you want the results to be.
    intent : string, optional
        Intent for plotting
    target_dens : float, optional
        Target density for plot
    is_mean : bool, optional
        True to plot mean values
    kwargs: dict, optional
        Dictionary with plotting parameters (only for given intent)
    """
    # Define bins
    width = {}
    width["in"] = density["sample"]["data"][pore_id]["in_width"][:-1] if "pore" in density["sample"] else []
    width["ex"] = density["sample"]["data"]["ex_width"][:]

    # Full plot
    if not intent:
        # Plot
        plt.figure(figsize=(10, 7))

        plt.subplot(211)
        plt.title(pore_id)
        sns.lineplot(x=width["in"], y=density["num_dens"][pore_id]["in"])
        if is_mean:
            sns.lineplot(x=width["in"], y=[density["mean"][pore_id]["in"] for x in width["in"]])

        plt.xlim([0, width["in"][-1]])
        plt.xlabel("Distance from pore center (nm)")
        plt.ylabel(r"Density (atoms nm$^{-3}$)")
        plt.legend(["Density", "Mean"])

        plt.subplot(212)
        sns.lineplot(x=width["ex"], y=density["num_dens"]["ex"])
        if is_mean:
            sns.lineplot(x=width["ex"], y=[density["mean"]["ex"] for x in width["ex"]])

        if target_dens:
            sns.lineplot(x=width["ex"], y=[target_dens]*len(width["ex"]))

        plt.xlim([0, width["ex"][-1]])
        plt.xlabel("Distance from reservoir end (nm)")
        plt.ylabel(r"Density in (atoms nm$^{-3}$)")
        if is_mean:
            plt.legend(["Density Ex", "Mean Ex", "Target density"])
        else:
            plt.legend(["Density Ex", "Target density"])

    # Intent plots
    else:
        if intent not in ["in", "ex"]:
            print("Invalid intent. Check documentation for available options.")
            return
        elif intent=="in":
            sns.lineplot(x=width[intent], y=density["num_dens"][pore_id][intent], **kwargs)
            plt.xlim([0, width[intent][-1]])
        else:
            sns.lineplot(x=width[intent], y=density["num_dens"][intent], **kwargs)
            plt.xlim([0, width[intent][-1]])


def mean(density, is_print=True, int_limit=2.5):
    """This function uses the desnity slope obtained from function
    :func:`poreana.density.bins` to calculate a weighted density inside the pore

    .. math::

        \\langle\\rho\\rangle
        =\\frac{\\int\\rho(r)dA(r)}{\\int dA(r)}.

    In a discrete form, following formula is evaluated

    .. math::

        \\langle\\rho\\rangle=\\frac{\\sum_{i=1}^n\\rho(r_i)A(r_i)}{\\sum_{i=1}^nA(r_i)}

    with the partial area

    .. math::

        A(r_i)=\\pi(r_i^2-r_{i-1}^2)

    of radial bin :math:`i`.

    Parameters
    ----------
    density : dictionary
        Density object from the density calculation :func:`bins`
    is_print : bool
        True to print result
    int_limit : float
        Upper integration limit

    Returns
    -------
    mean : dictionary
        Weighted mean density in :math:`\\frac{\\text{#}}{\\text{nm}^3}`
        **num_dens** and :math:`\\frac{\\text{kg}}{\\text{m}^3}` **dens**
    """
    # Initialize
    num_dens_weight = {}
    dens_weight = {}

    # Loop over different pores
    for pore_id in density["sample"]["pore"].keys():     
            if pore_id[:5]=="shape":
                bin_num = len(density["sample"]["data"][pore_id]["in_width"][:-1])
                width = density["sample"]["data"][pore_id]["in_width"][:-1]
                num_dens = density["num_dens"][pore_id]["in"]
                mass = density["sample"]["inp"]["mass"]

                # Integrate density
                num_dens_int = 0
                sum_surf = 0
                for i in range(bin_num-1):
                    if num_dens[i]>0:
                        if (width[i]<int_limit):
                            num_dens_int += num_dens[i]*(width[i+1]**2-width[i]**2)
                            sum_surf += (width[i+1]**2-width[i]**2)

                # Normalize
                num_dens_weight[pore_id] = num_dens_int/sum_surf

                # Mass denisty
                dens_weight[pore_id] = mass*10/6.022*num_dens_weight[pore_id]

    if is_print:
        for pore_id in num_dens_weight.keys():
            print("Mean Density ("+pore_id+"): "+"%.3f" % num_dens_weight[pore_id]+" #/nm^3; "+"%.3f" % dens_weight[pore_id]+" kg/m^3")

    return {"num_dens": num_dens_weight, "dens": dens_weight}
