################################################################################
# Density                                                                      #
#                                                                              #
"""Analyse density in a pore."""
################################################################################


import math
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

import poreana.utils as utils


def calculate(link_data, area=[[10, 90], [10, 90]], target_dens=None, is_print=True):
    """This function calculates the density inside and outside of the pore.
    This is done by calculating the number density :math:`\\rho_n` and using the
    molar mass :math:`M` of the molecule to determine the mass density
    :math:`\\rho`.

    The basic idea is counting the number of molecules :math:`N_i` in volume
    slices :math:`V_i`, thus getting the number density :math:`\\rho_{n,i}` in
    these sub volumes. Inside the pore this is done by creating a radial slicing
    like the radial distribution function. These sub volumes are calculated by

    .. math::

        V_i^\\text{radial}=\\pi z_\\text{pore}(r_i^2-r_{i-1}^2).

    with pore length :math:`z_\\text{pore}` and radius :math:`r_i` of sub volume
    :math:`i`. This yields

    .. math::

        \\rho_{n,i}^\\text{radial}=\\frac{N_i}{V_i^\\text{radial}}=\\frac{N_i}{\\pi z_\\text{pore}}\\frac{1}{r_i^2-r_{i-1}^2}.

    Outside the pore, the sub volumes are given by

    .. math::

        V_j^\\text{out}=(x_\\text{pore}\\cdot y_\\text{pore}-\\pi r^2)z_j

    with pore width :math:`x_\\text{pore}`, height :math:`y_\\text{pore}`, pore
    radius :math:`r` and slice width :math:`z_j`. Thus

    .. math::

        \\rho_{n,j}^\\text{out}=\\frac{N_j}{V_j^\\text{out}}=\\frac{N_j}{x_\\text{pore}\\cdot y_\\text{pore}-\\pi r^2}\\frac{1}{z_j}.

    Note that the outside refers to the reservoirs of the pore simulation.
    Therefore the slices add up to the reservoir length :math:`z_{res}`.
    Since there is a reservoir on each side, they are brought together
    by translating the atom coordinates to one of the reservoirs. Since the
    outside density refers to the density of the outside surface, it does
    not contain the cylindrical extension of the pore inside the reservoirs.

    Finally, the mass density is calculated by

    .. math::

        \\rho=\\frac M{N_A}\\rho_n

    with Avogadro constant :math:`N_A`. The units are then transformed to
    :math:`\\frac{\\text{kg}}{\\text m^3}` by

    .. math::

        [\\rho]=\\frac{[M]\\frac{\\text{g}}{\\text{mol}}}{[N_A]10^{23}\\frac{\\#}{\\text{mol}}}[\\rho_n]\\frac{\\#}{\\text{nm}^3}
               =\\frac{[M]}{[N_A]}[\\rho_n]\\cdot10\\frac{\\text{kg}}{\\text m^3}

    where the square brackets mean, that only the variables value is taken.
    Since finding full molecules in a sub volume is difficult, the atoms
    of the specified molecule are counted in the sub volumes and the result
    is then divided by the number of atoms the molecule consists of.

    Parameters
    ----------
    link_data : string
        Link to data object generated by the sample routine :func:`sample`
    area : list,  optional
        Bin areas to calculate the mean number density from (pore,out)
    target_dens : float, None, optional
        Target density in :math:`\\frac{\\text{kg}}{\\text{m}^3}`
    is_print : bool, optional
        True to print output
    """
    # Load data object
    sample = utils.load(link_data)

    # Load bins
    bin_in = sample["in"]
    bin_out = sample["out"]
    bin_num = len(bin_out[0])-1

    # Load input data
    inp = sample["inp"]
    num_frame = inp["frame"]
    entry = inp["entry"]
    res = inp["res"]
    diam = inp["diam"]
    box = inp["box"]
    mass = inp["mass"]

    # Calculate bin volume
    vol_in = [math.pi*(box[2]-2*res-2*entry)*(bin_in[0][i+1]**2-bin_in[0][i]**2) for i in range(0, bin_num+1)]
    vol_out = [2*bin_out[0][1]*(box[0]*box[1]-math.pi*(diam/2)**2) for i in range(bin_num+1)]

    # Calculate the number density
    num_dens_in = [bin_in[1][i]/vol_in[i]/num_frame for i in range(bin_num+1)]
    num_dens_out = [bin_out[1][i]/vol_out[i]/num_frame for i in range(bin_num+1)]

    # Calculate the mean in the selected area
    mean_in = np.mean(num_dens_in[area[0][0]:area[0][1]])
    mean_out = np.mean(num_dens_out[area[1][0]:area[1][1]])

    # Calculate Density
    dens_in = mass*10/6.022*mean_in
    dens_out = mass*10/6.022*mean_out

    # Calculate difference to target density
    num_diff = (target_dens/mass/10*6.022-mean_out)*box[0]*box[1]*res*2 if target_dens is not None else None

    # Output
    if is_print:
        print("Density inside  Pore = "+"%5.3f"%mean_in+" #/nm^3 ; "+"%7.3f"%dens_in+" kg/m^3")
        print("Density outside Pore = "+"%5.3f"%mean_out+" #/nm^3 ; "+"%7.3f"%dens_out+" kg/m^3")
        if target_dens is not None:
            print("Density difference   = "+"%5.3f" % (target_dens-dens_out)+" kg/m^3 ; "
                  +"%4.2f" % ((1-dens_out/target_dens)*100)+" % ; "
                  +"%3i" % num_diff+" #")

    # Return output
    return  {"in": [bin_in, num_dens_in, mean_in, dens_in], "out": [bin_out, num_dens_out, mean_out, dens_out], "inp": inp, "diff": num_diff}


def plot(density, intent=None, target_dens=None, is_mean=False):
    """This function plots the density of the given object. If an intent is
    given instead of None, only a plot-function will be called. Available
    options for ``intent`` are

    * **None** - Create subplots for the density inside and outside the pore
    * **in** - Create plot for the density inside pore
    * **out** - Create plot for the density outside pore

    Parameters
    ----------
    density : dictionary
        Density object from the density calculation :func:`calculate`
    intent : string, None, optional
        Intent for plotting
    target_dens : float, None, optional
        Target density for plot, None to disable
    is_mean : bool, optional
        True to plot mean values
    """
    # Full plot
    if intent is None:
        # Plot
        plt.figure(figsize=(10, 7))

        sns.set(style="whitegrid")
        sns.set_palette(sns.color_palette("deep"))

        plt.subplot(211)
        sns.lineplot(x=density["in"][0][0][:-1], y=density["in"][1], linewidth=2.5)
        if is_mean:
            sns.lineplot(x=density["in"][0][0][:-1], y=[density["in"][2] for x in density["in"][0][0][:-1]])

        plt.xlim([0, density["in"][0][0][-1]])
        plt.xlabel("Distance from pore center (nm)")
        plt.ylabel(r"Density (atoms nm$^{-3}$)")
        plt.legend(["Density", "Mean"])

        plt.subplot(212)
        #
        sns.lineplot(x=density["out"][0][0], y=density["out"][1], linewidth=2.5)
        if is_mean:
            sns.lineplot(x=density["out"][0][0], y=[density["out"][2] for x in density["out"][0][0]])

        if target_dens is not None:
            sns.lineplot(x=density["out"][0][0], y=[target_dens]*len(density["out"][0][0]))

        plt.xlim([0, density["out"][0][0][-1]])
        plt.xlabel("Distance from reservoir end (nm)")
        plt.ylabel(r"Density in (atoms nm$^{-3}$)")
        if is_mean:
            plt.legend(["Density Out", "Mean Out", "Target density"])
        else:
            plt.legend(["Density Out", "Target density"])

    # Intent plots
    else:
        if intent == "in":
            bins = density[intent][0][0][:-1]
        elif intent == "out":
            bins = density[intent][0][0]
        else:
            print("Invalid intent. Check documentation for available options.")
            return

        sns.lineplot(x=bins, y=density[intent][1])
        plt.xlim([0, density[intent][0][0][-1]])
