################################################################################
# Adsorption                                                                   #
#                                                                              #
"""Analyse adsorption in a pore."""
################################################################################


import numpy as np

import poreana.utils as utils


def calculate(link_pore, link_data, res_cutoff=1, is_normalize=True):
    """This function calculates the values for the adsorption isotherms. This is
    done by counting the number of molecules inside the reservoir and within the
    pore over the whole simulation.

    By normalizing the summation by the number of frames, the resulting value
    is converted to a surface specific concentration inside the pore and volume
    specific concentration within the reservoir.

    The resulting value pair is a point in the adsorption isotherm.

    Parameters
    ----------
    link_pore : string
        Link to poresystem object file
    link_data : string
        Link to data object generated by the density sample routine
        :func:`poreana.sample.density`
    res_cutoff : float, optional
        Area of the reservoir to remove from counting on both sides of the
        reservoir
    is_normalize : bool, optional
        True to normalize the number of atoms with the number of frames

    Returns
    -------
    adsorption : dictionary
        Normalized number of molecules outside and insidem and value pair of a
        point on the adsorption isotherm
        :math:`\\left[\\frac{\\text{mmol}}{\\text{l}}\\ ,\\frac{\\mu\\text{mol}}{\\text{m}^2}\\right]`
    """
    # Load pore properties
    pore = utils.load(link_pore)
    res = pore.reservoir()
    diam = pore.diameter()
    box = pore.box()

    # Load data object
    sample = utils.load(link_data)

    # Load bins
    bin_in = sample["in"]
    bin_out = sample["out"]

    # Load input data
    inp = sample["inp"]
    num_frames = inp["frame"]
    entry = inp["entry"]

    # Calculate number of molecules
    num_in = sum(bin_in[1])
    num_out = sum([num_mol for i, num_mol in enumerate(bin_out[1]) if bin_out[0][i] <= res-res_cutoff and bin_out[0][i] >= res_cutoff])

    # Normalize number of instances by the number of frames
    num_in /= num_frames if is_normalize else 1
    num_out /= num_frames if is_normalize else 1

    # Calculate surface and volume
    surface = 2*np.pi*(diam)/2*(box[2]-2*entry)
    volume = 2*(res-2*res_cutoff)*box[0]*box[1]

    # Convert to concentrations
    mumol_m2 = utils.mols_to_mumol_m2(num_in, surface)
    mmol_l = utils.mols_to_mmol_l(num_out, volume)

    return {"c": [mmol_l, mumol_m2], "n": [num_out, num_in]}
