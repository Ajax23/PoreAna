################################################################################
# Diffusion                                                                    #
#                                                                              #
"""Analyse diffusion in a pore."""
################################################################################


import math
import warnings
import itertools
import scipy as sp
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

import poreana.utils as utils


###################
# Diffusion - Bin #
###################
def cui(data_link, z_dist=0, ax_area=[0.2, 0.8], intent="", is_fit=False, is_plot=True):
    """This function samples and calculates the diffusion coefficient of a
    molecule group in a pore in both axial and radial direction, as described
    in the paper of `Cui <https://doi.org/10.1063/1.1989314>`_.

    The mean square displacement is sampled in function
    :func:`poreana.sample.Sample._diffusion_bin`.

    The axial diffusion is given by the Einstein relation

    .. math::

        \\langle\\left[z(0)-z(t)\\right]^2\\rangle=2D_\\text{axial}t

    with axial diffusion coefficient :math:`D_\\text{axial}`. Thus the
    coefficient corresponds to the slope of the axial msd

    .. math::

        D_\\text{axial}=\\frac12\\frac{\\text{msd}_\\text{axial}[i]-\\text{msd}_\\text{axial}[j]}{t_i-t_j}

    with bin :math:`i>j`. The radial diffusion is given by

    .. math::

        \\langle\\left[r(0)-r(t)\\right]^2\\rangle=R^2\\left[1-\\sum_{n=1}^\\infty\\frac{8}{\\lambda_{1n}^2(\\lambda_{1n}^2-1)}\\exp\\left(-\\frac{\\lambda_{1n}^2}{R^2}D_\\text{radial}t\\right)\\right].

    with radial diffusion coefficient :math:`D_\\text{radial}`, the maximal
    accessible radial position :math:`R` by an atom

    .. math::

        R = \\frac12d-0.2

    with pore diameter :math:`d`, and the zeros :math:`\\lambda_{1n}^2` of
    the derivative

    .. math::

        \\frac{dJ_1}{dx}

    of the first order Bessel function :math:`J_1`. Therefore the coefficient
    has to be fitted to the sampled radial msd. The author observed that
    the first 20 Bessel function zeros were sufficient for the function fit.

    The final unit transformation is done by

    .. math::

        \\frac{\\text{nm}^2}{\\text{ps}}=10^{-2}\\frac{\\text{cm}^2}{\\text{s}}.

    **Note that the function for the radial diffusion is obtained under the
    assumption that the density inside the pore is uniform.**

    Parameters
    ----------
    data_link : string
        Link to data object generated by the sample routine
        :func:`poreana.sample.Sample._diffusion_bin`
    z_dist : float, optional
        Distance from pore centre to calculate the mean
    ax_area : list, optional
        Bin area percentage to calculate the axial diffusion coefficient
    intent : string, optional
        axial, radial or empty for both
    is_fit : bool, optional
        True to plot the fitted function
    is_plot : bool, optional
        True to create plot in this function
    """
    # Load data object
    sample = utils.load(data_link)

    # Load data
    pore = sample["pore"]
    inp = sample["inp"]
    bins = inp["bin_num"] if not z_dist else math.floor(z_dist/sample["data"]["width"][1])
    msd_z = [0 for x in range(inp["len_window"])]
    msd_r = [0 for x in range(inp["len_window"])]
    norm_z = [0 for x in range(inp["len_window"])]
    norm_r = [0 for x in range(inp["len_window"])]

    # Sum up all bins
    for i in range(bins):
        for j in range(inp["len_window"]):
            msd_z[j] += sample["data"]["z_tot"][i][j]
            norm_z[j] += sample["data"]["n_tot"][i][j]

    for i in range(inp["bin_num"]):
        for j in range(inp["len_window"]):
            msd_r[j] += sample["data"]["r_tot"][i][j]
            norm_r[j] += sample["data"]["n_tot"][i][j]

    # Normalize
    msd_z_n = [msd_z[i]/norm_z[i] if norm_z[i] > 0 else 0 for i in range(inp["len_window"])]
    msd_r_n = [msd_r[i]/norm_r[i] if norm_r[i] > 0 else 0 for i in range(inp["len_window"])]

    # Define time axis and range
    time_ax = [x*inp["len_step"]*inp["len_frame"] for x in range(inp["len_window"])]
    t_range = (inp["len_window"]-1)*inp["len_step"]*inp["len_frame"]

    # Calculate axial coefficient
    if not intent or intent == "axial":
        dz = (msd_z_n[int(ax_area[1]*inp["len_window"])]-msd_z_n[int(ax_area[0]*inp["len_window"])])*1e-9**2/((ax_area[1]-ax_area[0])*t_range)/2*1e2**2*1e5  # 10^-9 m^2s^-1

        print("Diffusion axial:  "+"%.3f" % dz+" 10^-9 m^2s^-1")

    # Calculate radial coefficient
    if not intent or intent == "radial":
        def diff_rad(x, a, b, c):
            # Process input
            x = x if isinstance(x, list) or isinstance(x, np.ndarray) else [x]

            # Get bessel function zeros
            jz = sp.special.jnp_zeros(1, math.ceil(b))
            # Calculate sum
            sm = [[8/(z**2*(z**2-1))*math.exp(-(z/c)**2*a*t) for z in jz] for t in x]
            # Final equation
            return [c**2*(1-sum(s)) for s in sm]

        # Fit function
        popt, pcov = sp.optimize.curve_fit(diff_rad, [x*1e12 for x in time_ax], msd_r_n, p0=[1, 20, pore["diam"]/2-0.2], bounds=(0, np.inf))

        print("Diffusion radial: "+"%.3f" % (popt[0]*1e3)+" 10^-9 m^2 s^-1; Number of zeros: "+"%2i" % (math.ceil(popt[1]))+"; Radius: "+"%5.2f" % popt[2])

    # Plot
    if is_plot:
        legend = []

    if not intent or intent == "axial":
        sns.lineplot(x=[x*1e12 for x in time_ax], y=msd_z_n)
        if is_plot:
            legend += ["Axial"]
        if is_fit:
            sns.lineplot(x=[x*1e12 for x in time_ax], y=[dz*2*time_ax[x]/1e5/1e-7**2 for x in range(inp["len_window"])])
            legend += ["Fitted Axial"]

    if not intent or intent == "radial":
        sns.lineplot(x=[x*1e12 for x in time_ax], y=msd_r_n)
        if is_plot:
            legend += ["Radial"]
        if is_fit:
            sns.lineplot(x=[x*1e12 for x in time_ax], y=diff_rad([x*1e12 for x in time_ax], *popt))
            legend += ["Fitted Radial"]

    if is_plot:
        plt.xlabel("Time (ps)")
        plt.ylabel(r"Mean square displacement (nm$^2$)")
        plt.legend(legend)


def bins(data_link, ax_area=[0.2, 0.8], is_norm=False):
    """This function calculates the axial (z-axis) diffusion coefficient as a
    function of the radial distance. This is done by sampling the mean square
    displacement for all molecules in a radial sub volume.

    The mean square displacement is sampled in function
    :func:`poreana.sample.Sample._diffusion_bin`.

    For each bin, the msd is summed up, resulting into a msd slope for each
    bin. Thus, the axial diffusion coefficient can be calculated using

    .. math::

        D_\\text{axial}=\\frac12\\frac{\\text{msd}_\\text{axial}[i]-\\text{msd}_\\text{axial}[j]}{t_i-t_j}.

    Note that the msd is evaluated in the area, where the slope is uniform,
    which means that the first twenty and last twenty percent should be
    neglected.

    If ``is_norm`` is set to **True**, the radius will be normalized in respect
    to the effective radius which means, the last radius that has a
    Diffusion greater than zero is taken

    .. math::

        r_\\text{norm}=\\frac{1}{r_\\text{eff}}r.

    Parameters
    ----------
    data_link : string
        Link to data object generated by the sample routine :func:`poreana.sample.Sample._diffusion_bin`
    ax_area : list, optional
        Bin area percentage to calculate the axial diffusion coefficient
    intent : string, optional
        Set to **plot**, for plotting or set to **line** to only return the
        lineplot, leave empty for nothing
    is_norm : bool, optional
        True to normalize x-axis

    Returns
    -------
    diffusion : list
        List of the slope of the non-normalized diffusion coefficient
    """
    # Load data object
    sample = utils.load(data_link)

    # Load data
    inp = sample["inp"]
    width = sample["data"]["width"]
    msd_z = sample["data"]["z"]
    norm = sample["data"]["n"]

    # Normalize
    msd_norm = [[msd_z[i][j]/norm[i][j] if norm[i][j] > 0 else 0 for j in range(inp["len_window"])] for i in range(inp["bin_num"]+1)]

    # Calculate slope
    f_start = int(ax_area[0]*inp["len_window"])
    f_end = int(ax_area[1]*inp["len_window"])
    time_ax = [x*inp["len_step"]*inp["len_frame"] for x in range(inp["len_window"])]
    slope = [(msd_norm[i][f_end]-msd_norm[i][f_start])/(time_ax[f_end]-time_ax[f_start]) for i in range(inp["bin_num"]+1)]

    # Calculate diffusion coefficient
    diff = [msd*1e-9**2/2*1e2**2*1e5 for msd in slope]  # 10^-9 m^2s^-1

    return {"width": width, "diff": diff, "is_norm": is_norm}


def bins_plot(data, intent="plot", kwargs={}):
    """This function calculates the axial plots the diffusion profile calculated
    by the function :func:`poreana.diffusion.bins`.

    Parameters
    ----------
    data : string
        Data dictionary from function func:`poreana.diffusion.bins`
    intent : string, optional
        Set to **plot**, for plotting or set to **line** to only return the
        lineplot, leave empty for nothing
    kwargs: dict, optional
        Dictionary with plotting parameters
    """
    # Initialize
    width = data["width"]
    diff = data["diff"]
    is_norm = data["is_norm"]

    # Normalize x-axis
    if is_norm:
        for i in range(len(diff)-1, 0, -1):
            if diff[i] > 0:
                x_max = width[i+1]
                break

        bins_norm = [x/x_max for x in width]

    # Plot
    if intent == "plot" or intent == "line":
        x_axis = bins_norm if is_norm else width
        sns.lineplot(x=x_axis[:-1], y=diff, **kwargs)

    if intent == "plot":
        if is_norm:
            plt.xlabel("Normalized distance from pore center")
        else:
            plt.xlabel("Distance from pore center (nm)")
        plt.ylabel(r"Diffusion coefficient ($10^{-9}$ m${^2}$ s$^{-1}$)")


def mean(diff_data, dens_data, ax_area=[0.2, 0.8], is_norm=False, is_check=False):
    """This function uses the diffusion coefficient slope obtained from
    function :func:`poreana.diffusion.bins` and the density slope of function
    :func:`poreana.density.bins` to calculate a weighted diffusion
    coefficient inside the pore

    .. math::

        \\langle D_\\text{axial}\\rangle
        =\\frac{\\int\\rho(r)D_\\text{axial}(r)dA(r)}{\\int\\rho(r)dA(r)}.

    In a discrete form, following formula is evaluated

    .. math::

        \\langle D_\\text{axial}\\rangle=\\frac{\\sum_{i=1}^n\\rho(r_i)D_\\text{axial}(r_i)A(r_i)}{\\sum_{i=1}^n\\rho(r_i)A(r_i)}

    with the partial area

    .. math::

        A(r_i)=\\pi(r_i^2-r_{i-1}^2)

    of radial bin :math:`i`.

    Parameters
    ----------
    diff_data : dictionary
        Diffusion data dictionary from function :func:`poreana.diffusion.bins`
    dens_data : dictionary
        Density data dictionary from function :func:`poreana.density.bins`
    ax_area : list, optional
        Bin area percentage to calculate the axial diffusion coefficient
    is_norm : bool, optional
        True to normalize x-axis
    is_check : bool, optional
        True to plot density function fit

    Returns
    -------
    diff_weight : float
        Density weighted mean axial diffusion in 10^-9 m^2s^-1
    """
    # Get number of bins
    bin_num = len(diff_data["width"][:-1])

    # Set diffusion functions
    width = diff_data["width"][:-1]
    diff = diff_data["diff"]

    # Fit density function
    with warnings.catch_warnings():
        warnings.filterwarnings('ignore', r'Polyfit may be poorly conditioned')
        param = np.polyfit(dens_data["sample"]["data"]["in_width"][:-1], dens_data["num_dens"]["in"], 100)
        dens_f = np.poly1d(param)(width)

    # Plot fit
    if is_check:
        sns.lineplot(x=dens_data["sample"]["data"]["in_width"][:-1], y=dens_data["num_dens"]["in"])
        sns.lineplot(x=width, y=dens_f)

    # Integrate density
    dens_int = sum([dens_f[i]*(width[i+1]**2-width[i]**2) for i in range(bin_num-1)])

    # Calculate weighted diffusion
    diff_int = sum([dens_f[i]*diff[i]*(width[i+1]**2-width[i]**2) for i in range(bin_num-1)])

    # Normalize
    diff_weight = diff_int/dens_int

    print("Mean Diffusion axial: "+"%.3f" % diff_weight+" 10^-9 m^2s^-1")

    return diff_weight


######################################
# Diffusion - MC - Transition Matrix #
######################################
def mc_trans_mat(link_in, step, kwargs={}):
    """This function plots the occupation of a normalized transition matrix as a
    heatmap. To normalize the transition matrix the number of the frame are used.
    This means that all entries in the transition matrix are divided by the
    total number of frames which are used to estimate the matrix.

    Parameters
    ----------
    link_out: string
        Link to the diffusion data object generated by the sample routine
        :func:`poreana.sample.Sample.init_diffusion_mc` or the MC run
        :func:`poreana.mc.MC.run`
    step: integer
        Step length for which the transition matrix is to be displayed
    kwargs: dict, optional
        Dictionary with plotting parameters
    """

    # Load results from the output object file
    data= utils.load(link_in)

    # Sample obj file is loaded
    if "data" in data:
        trans_mat = data["data"]
        inp = data["inp"]
        frame_num = inp["num_frame"]
        frame_length = inp["len_frame"] * 10**12

    # MC obj file is loaded
    else:
        model = data["model"]
        trans_mat = model["data"]
        frame_num = model["num_frame"]
        frame_length = model["len_frame"]

    # Set title with selected lag time
    plt.title("Lagtime: "+ str(step * frame_length) + " ps", fontsize=10)

    # Plot the normalized transition matrix in a heatmap
    sns.heatmap(trans_mat[step]/frame_num, **kwargs)


##################
# Diffusion - MC #
##################
def mc_fit(link, len_step=[], is_std=True, section=[], kwargs={}):
    """This function uses the diffusion profiles over box length which are
    calculated in the function :func:`poreana.mc.MC.run` to estimate
    the final diffusion coefficient. For that a line is fitted of the averaged
    diffusion profiles :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}})` for the
    different lag times as a function of :math:`1/\\Delta_{ij}t_{\\alpha}`. The
    function plots all mean diffusion
    :math:`D_\\mathrm{mean}({\\Delta_{ij}t_{\\alpha}})` over the
    inverse lag times and the linear fit. Additionally, the final diffusion
    coefficient :math:`D` for a lag time
    :math:`\\Delta_{ij}t_{\\alpha} \\rightarrow \infty` is printed. Also, a table
    of the selected step length and the belonging
    :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}})` can be displayed.

    In order to be able to estimate how the choice of lag times affects the
    result, an additional error estimation is possible. For this all possible
    fourth tuples of the entire calculated lag times are used to estimate a
    mean diffusion coefficient :math:`\\langle D \\rangle` which is the mean
    value of all fourth tuples fitting results. Also, the standard deviation of
    all fitting results is printed. If there is no big difference between the
    diffusion coefficient :math:`D` and the mean diffusion coefficient
    :math:`\\langle D \\rangle`, all :math:`D_\\mathrm{mean}({\\Delta_{ij}t_{\\alpha}})`
    are on a straight line. The standard deviation also can be used to check
    if the result fluctuates strongly at the choice of other lag times. This
    error estimate is calculated if :math:`\\mathrm{is}\_{\\mathrm{std}}=True`.

    Parameters
    ----------
    link: string
        Link to the diffusion data object generated by the MC Alogrithm
        :func:`poreana.mc.MC.run`
    len_step: integer, list, optional
        List of the different step length, if it is [] all calculated lag times
        will be used to fit the diffusion coefficent
    is_std : bool, optional
        True to calculate a mean diffusion coefficient
        to assess the dependency of the result on the selected lag time
    section : list, string, optional
        If :math:`\\mathrm{section} = \\mathrm{"is\_pore"}` the pore section is
        fitted.
        If :math:`\\mathrm{section} = \\mathrm{"is\_res"}` the left reservoir
        area is fitted.
        If :math:`\\mathrm{section} = \\mathrm{[a,b]}` the box area between a
        and b is fitted.
    kwargs: dict, optional
        Dictionary with plotting parameters

    Returns
    -------
    diffusion: float
        Diffusion coefficient :math:`D \ \\left(\\frac{m^2}{s}\\right)` for the
        calculated system
    diffusion_mean: float
        Mean diffusion coefficient :math:`\\langle D \\rangle \ \\left(\\frac{m^2}{s}\\right)`
        for the calculated system
    diff_table : obj
        Table of used lag times with the associated
        :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}}) \ \\left(\\frac{m^2}{s}\\right)`
    """

    data = utils.load(link)

    # Load results
    results = data["output"]
    diff_bin = results["diff_profile"]

    # Load model inputs
    model = data["model"]
    diff_unit = model["diffusion unit"]
    bins = model["bins"]
    bins = [(bins[i] + (bins[1]-bins[0])) for i in range(len(bins))]
    dt = model["len_frame"]

    # Set vector
    diff_bin_vec = {}

    # Pore
    if isinstance(section, str) and section== "is_pore":
        # If only the pore area should be considered
        # Load pore system
        if "pore" in data:
            pore = data["pore"]
            res = pore["res"]
            box = pore["box"]

            # Set section
            section_list = [res, box[2]-res]

        # If only the pore area should be considered
        else:
            print("obj.-file includes results of a simple box")
            return;

    # Reservoir
    elif isinstance(section, str) and section== "is_res":
        # If only the pore area should be considered
        # Load pore system
        if "pore" in data:
            pore = data["pore"]
            res = pore["res"]
            box = pore["box"]

            # Set section
            section_list = [0,res]

        # If only the pore area should be considered
        else:
            print("obj.-file includes results of a simple box")
            return;

    #Area section
    elif isinstance(section, list):
        section_list = section

    # If section is not defined -> entire system
    if not section:
        # Set section
        section_list = [bins[0], bins[-1]]

    # Cut profile
    # Calculated start and end bin index of the pore area
    index_start = np.digitize(section_list[0], bins)
    index_end = np.digitize(section_list[1], bins)

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
        len_step = model["len_step"]


    for i in len_step:
        diff_bin_vec[i] = {}
        diff_bin_vec[i] = [diff_bin[i][j] for j in range(index_start, index_end)]

    # Calculate mean diffusion coefficient and standard deviation
    # Mean diffusion means the averaged of all possible fourth tuple fitting results
    if is_std:
        len_step_all = len_step

        # Determine all possible combinations
        a = list(itertools.combinations(len_step_all, 2))

        # Allocate the result vector
        res = np.zeros(len(a))

        # Fit to infinity lag time for all combinations
        for i in range(len(a)):

            # Set the current tuple
            rand = list(a[i])

            # Calculate the mean diffusion (m^2/s) over all bins
            D_mean = [np.mean(np.exp(diff_bin_vec[i] + diff_unit)) * 10**-6 for i in rand]

            # Calculate the inverse lag time for the linear fit
            lagtime_inverse = [1 / (i * dt * 10**-12) for i in rand]

            # Fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse, D_mean, 1))

            # Set the x value for the linear fit
            x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5)

            # Set the fitted diffusion coefficient on the results list
            res[i] = fit(0)

        # Determine standard deviation and mean diffusion of fourth touple method
        diffusion_mean = np.mean(res)
        std = res.std()

    # Calculate the mean diffusion (m^2/s) over all bins
    D_mean = [np.mean(np.exp(diff_bin_vec[i] + diff_unit)) * 10**-6 for i in len_step]

    # Calculate the inverse lag time (1/s) for the linear fit
    lagtime_inverse = [1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]

    # Fit a linear line
    fit = np.poly1d(np.polyfit(lagtime_inverse, D_mean, 1))

    # Print the diffusion coefficient for an entire system
    if not section:
        print("\nDiffusion axial: "+"%.4e" % fit(0) + " m^2/s\n")
        # If is_std true print the results of the calculations
        if is_std:
            print("Mean Diffusion axial: "+"%.4e" % diffusion_mean + " m^2/s\n")

    # Print the diffusion coefficient in the pore area
    if section=="is_pore":
        print("\nDiffusion axial (Pore): "+"%.4e" % fit(0) + " m^2/s\n")
        # If is_std true print the results of the calculations
        if is_std:
            print("Mean Diffusion axial (Pore): "+"%.4e" % diffusion_mean + " m^2/s\n")

    # Print the diffusion coefficient in the reservoir area
    if section=="is_res":
        print("\nDiffusion axial (Reservoir): "+"%.4e" % fit(0) + " m^2/s\n")
        # If is_std true print the results of the calculations
        if is_std:
            print("Mean Diffusion axial (Peservoir): "+"%.4e" % diffusion_mean + " m^2/s\n")

    # Print the diffusion coefficient in a selected section
    if len(section) == 2:
        print("\nDiffusion axial ([" + "%.2f" % (section_list[0]) + ", " + "%.2f" % (section_list[1]) + "]): "+"%.4e" % fit(0) + " m^2/s\n")
        # If is_std true print the results of the calculations
        if is_std:
            print("Mean Diffusion axial (["+ "%.2f" % (section_list[0]) + ", " + "%.2f" % (section_list[1]) +"]): "+"%.4e" % diffusion_mean + " m^2/s\n")

    # Print std deviation
    if is_std:
        print("Standard deviation: "+"%.4e" % std + " m^2/s\n")

    # Set data frame for the used lag times
    data = [str("%.2e" % D_mean[i]) + " $\mathrm{m^2s^{-1}}$" for i in range(len(len_step))]
    diff_table = pd.DataFrame(data, index=list(len_step), columns=list(['$D_\mathrm{mean}$']))
    diff_table = pd.DataFrame(diff_table.rename_axis('Step Length', axis=1))
    styler = diff_table.style.set_caption('Selected step length')
    diff_table = styler.set_properties(**{'text-align': 'right'})
    diff_table = diff_table.set_table_styles([dict(selector='th', props=[('text-align', 'left')])])

    # Set vectors for plotting
    D_mean_vec = [D_mean[i] * 10 ** 9 for i in range(len(lagtime_inverse))]
    lag_time_vec = [1 / (len_step[i] * dt) for i in range(len(len_step))]
    x_vec = np.arange(0, max(lag_time_vec) * 2, (max(lag_time_vec) * 2) / 5)

    # Fit a linear line
    fit = np.poly1d(np.polyfit(lag_time_vec, D_mean_vec, 1))

    # Plot the results
    plt.xlim(0, 1.5*max(lag_time_vec))
    plt.ylim(0, 1.5*max(fit(x_vec)))
    sns.scatterplot(x=lag_time_vec, y=D_mean_vec, color='red', **kwargs)
    sns.lineplot(x=x_vec, y=fit(x_vec), **kwargs)
    legend = ["$D_{\mathrm{fit}}$", "$D_{\mathrm{mean}}(\Delta_{ij}t_{\\alpha})$"]
    plt.legend(legend)
    plt.xlabel(r"Inverse lag time ($10^{12} \ \mathrm{s^{-1}})$")
    plt.ylabel(r"Diff. coeff. ($10^{-9} \ \mathrm{m^2s^{-1}}$)")

    diffusion = fit(0) * 10**-9

    return diffusion, diffusion_mean, diff_table


def mc_profile(link, len_step=[], infty_profile=True, section=[], kwargs={}):
    """This function plots the diffusion profile for an infinity
    lag time (:math:`\\Delta_{ij}t_{\\alpha} \\rightarrow \\infty`) over the box
    fitted with the specified :math:`\\mathrm{len}\_\\mathrm{step}` list.
    Additionally, it is possible to display the diffusion profiles for the
    calculated lag times. Therefore, the
    :math:`\\mathrm{infty}\_\\mathrm{profile}` has to be false.
    The list :math:`\\mathrm{len}\_\\mathrm{step}`
    contains the calculated step length which should be
    displayed.

    Parameters
    ----------
    link : string
        Link to the diffusion data object generated by the MC Algorithm
        :func:`poreana.mc.MC.run`
    len_step : integer list, optional
        List of the different step length, if it is [] all diffusion profiles
        depending on the lag time are used to calculate the diffusion profile
        for an infinite lag time or the individual diffusion profiles for these
        lag times are shown
    infty_profile : bool, optional
        Set to false to display all individual diffusion profiles for
        the selected lag times
    section : list, string, optional
        If :math:`\\mathrm{section} = \\mathrm{"is\_pore"}` the pore section is
        fitted.
        If :math:`\\mathrm{section} = \\mathrm{"is\_res"}` the left reservoir
        area is fitted.
        If :math:`\\mathrm{section} = \\mathrm{[a,b]}` the box area between a
        and b is fitted.
    kwargs: dict, optional
        Dictionary with plotting parameters
    """


    # Load Results from the output object file
    data = utils.load(link)

    # Load results
    results = data["output"]
    diff_bin = results["diff_profile"]

    # Load model inputs
    model = data["model"]
    diff_unit = model["diffusion unit"]
    bins = model["bins"]
    bins = [(bins[i] + (bins[1]-bins[0])) for i in range(len(bins))]
    dt = model["len_frame"]

    # Set dictionaries
    legend = []
    diff_bin_vec = {}

    # Pore
    if isinstance(section, str) and section== "is_pore":
        # If only the pore area should be considered
        # Load pore system
        if "pore" in data:
            pore = data["pore"]
            res = pore["res"]
            box = pore["box"]

            # Set section
            section_list = [res, box[2]-res]

        # If only the pore area should be considered
        else:
            print("obj.-file includes results of a simple box")
            return;

    # Reservoir
    elif isinstance(section, str) and section== "is_res":
        # If only the pore area should be considered
        # Load pore system
        if "pore" in data:
            pore = data["pore"]
            res = pore["res"]
            box = pore["box"]

            # Set section
            section_list = [0,res]

        # If only the pore area should be considered
        else:
            print("obj.-file includes results of a simple box")
            return;

    #Area section
    elif isinstance(section, list):
        section_list = section

    # If section is not defined -> entire system
    if not section:
        # Set section
        section_list = [bins[0], bins[-1]]

    # Cut profile
    # Calculated start and end bin index of the pore area
    index_start = np.digitize(section_list[0], bins)
    index_end = np.digitize(section_list[1], bins)

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
        len_step = model["len_step"]

    # Save for all lag times the cutted profile
    for i in len_step:
        diff_bin_vec[i] = {}
        diff_bin_vec[i] = [diff_bin[i][j] for j in range(index_start, index_end)]

    bins = [bins[i] for i in range(index_start, index_end)]


    # Calculate the inverse lag time (1/s) for the linear fit
    lagtime_inverse = [1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]

    # Calculate diffusion profiles
    diff_profiles = [[np.exp(diff_bin_vec[i][j] + diff_unit) * 10 **3 for j in range(len(bins))] for i in len_step]

    # If infty_profile is false the profiles for the different lag times are plotted
    if not infty_profile:
        # Plot the profiles for the
        for i in range(len(len_step)):
            sns.lineplot(x=bins, y=(diff_profiles[i]), **kwargs)       # Diffusion in m^2/s

        # Plot the diffusion profiles for the different lag times
        legend = ["lag time " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

    # If infty_profile is True the diffusion profile for a infinity lag times is shwon
    if len(len_step) >= 2 and infty_profile:
        # Initialize fit vector
        diff_profile_fit = []

        # Calculate the mean diffusion over all bins
        for i in range(len(bins)):
            diff = [np.exp(diff_bin_vec[step][i] + diff_unit) * 10**-6 for step in len_step]   # Diffusion in m^2/s

            # fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse, diff, 1))

            # Append diffusion at t-> infty
            diff_profile_fit.append(fit(0)*10**9)

        # Plot fitted diffusion profile
        sns.lineplot(x=bins, y=diff_profile_fit, **kwargs)       # Diffusion in m^2/s

    # Set legend for lag times
    if not infty_profile:
        legend.append("Lagtime $\\infty$ ps")
        plt.legend(legend)


    # Set plot properties
    # Plot axis title for a entire system
    plt.ylabel(r"Diffusion ($10^{-9} \ \mathrm{m^2s^{-1}}$)")





###########################
# Diffusion - MC - Radial #
###########################
# def mc_fit_radial(link, len_step=None):
#     """This function uses the diffusion profiles over box length which are
#     calculated in the function :func:`do_mc_cycles` to estimate the final
#     diffusion coefficient. For that a line is fitted of the averaged diffusion
#     profiles :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}})` for the
#     different lag times as a function of :math:`1/\\Delta_{ij}t_{\\alpha}`. The
#     function plots all mean diffusion
#     :math:`D_{mean}({\\Delta_{ij}t_{\\alpha}})` over the inverse lag times and
#     the linear fit. Additional the final mean diffusion coefficient :math:`D`
#     for a lagtime :math:`\\Delta_{ij}t_{\\alpha} \\rightarrow \infty` is
#     printed. Also a table of the selected step length and the belonging
#     :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}})` can be displayed.
#
#     In order to be able to estimate how the choice of lag times affects the
#     result, an additional error estimation is possible. For this all possible
#     fourth tuples of the entire calculated lag times are used to estimate a
#     mean diffusion coefficient :math:`\\langle D \\rangle` which is the mean
#     value of all fourth tuples fitting results. Also the standard deviation of
#     all fitting results is printed. If there is no big difference between the
#     diffusion coefficient :math:`D` and the mean diffusion ceofficient
#     :math:`\\langle D \\rangle`, all :math:`D_{mean}({\\Delta_{ij}t_{\\alpha}})`
#     are on a straight line. The standard deviation can also be used to check
#     if the result fluctuates strongly at the choice of other lag times. This
#     error estimate is calculated if :math:`\\mathrm{is}_{\\mathrm{std}}=True`.
#
#     Parameters
#     ----------
#     link: string
#         Link to the diffusion data object generated by the sample routine
#         :func:`MC.do_mc_cycles`
#     len_step: integer list, optional
#         List of the different step length, if it is None the lag times which
#         are contains in the obj file are printed
#     is_std : bool, optional
#         True to calculate a mean diffusion coefficient and a Bootstrap diffusion
#         to assess the dependency of the results on the chosen lag time
#
#     Returns
#     -------
#     diffusion: float
#         Radial diffusion coefficient :math:`D \ \\left(\\frac{m^2}{s}\\right)` for the
#         calculated system
#     diffusion_mean: float
#         Radial mean diffusion coefficient :math:`\\langle D \\rangle \ \\left(\\frac{m^2}{s}\\right)` for the
#         calculated system
#     diff_table : obj
#         Table of used lag times with the associated
#         :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}}) \ \\left(\\frac{m^2}{s}\\right)`
#     """
#     # Load Results from the output object file
#     results = utils.load(link)
#     diff_bin = results["diff_radial_profile"]
#     df_bin = results["df_profile"]
#     inp = results["model"]
#     bins = inp["bins"]
#     diff_unit = inp["diffusion radial unit"]
#     dt = inp["len_frame"]
#
#     # If no specific step length is chosen take the step length from the object file
#     if not len_step:
#         len_step = inp["len_step"]
#
#     # Calculate the mean diffusion over all bins
#     D_mean = [np.mean(np.exp(diff_bin[i] + diff_unit)) * 10**-
#               6 for i in len_step]   # Diffusion in m^2/s
#
#     # Calculate the inverse lag time (1/s) for the linear fit
#     lagtime_inverse = [1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]
#
#     # Fit a linear line
#     fit = np.poly1d(np.polyfit(lagtime_inverse, D_mean, 1))
#
#     # set the x value for the linear fit
#     x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5)
#
#     # Calculate the diffusion coefficient as a mean value over the bin
#     print("\nMean Radial Diffusion: "+"%.4e" % fit(0) + " m^2/s\n")
#
#     # Integration
#     bin_width = bins[1]-bins[0]
#
#     # Set data frame for the used lag times
#     D_mean_pd = [str("%.2e" % D_mean[i]) for i in range(len(D_mean))]
#     diff_table = pd.DataFrame({'$D_\mathrm{mean}$': D_mean_pd, '$D_\mathrm{avg} (\mathrm{m^2s^{-1}})$': diff_avg_pd}, index=list(len_step))
#     diff_table = pd.DataFrame(diff_table.rename_axis('Step Length', axis=1))
#     styler = diff_table.style.set_caption('Selected step length')
#     diff_table = styler.set_properties(**{'text-align': 'right'})
#     diff_table = diff_table.set_table_styles([dict(selector='th', props=[('text-align', 'left')])])
#
#     # Plot the results
#     plt.xlim(0, 1.5*max(lagtime_inverse))
#     plt.ylim(0, 1.5*max(fit(x)))
#     sns.scatterplot(x=lagtime_inverse, y=D_mean, color='red')
#     sns.lineplot(x=x, y=fit(x))
#     legend = ["linear fit", "$D_{\mathrm{mean}}$"]
#     plt.legend(legend)
#     plt.xlabel(r"Inverse lagtime ($\mathrm{s^{-1}})$")
#     plt.ylabel(r"radial Diff. coeff. ($\mathrm{m^2s^{-1}}$)")
#
#     return fit(0), diff_table
#
#
# def mc_profile_radial(link, len_step=None, avg=False):
#     """This function plots the radial diffusion profile for a infinity
#     lag time (:math:`\\Delta_{ij}t_{\\alpha} \\rightarrow \\infty`) over the box
#     fitted with the specified :math:`\\mathrm{len}\_\\mathrm{step}` list.
#     Additionally, it is possible to display the diffusion profiles for the
#     calculated lag times. Therefore, the
#     :math:`\\mathrm{infty}\_\\mathrm{profile}` has to be false.
#     The list :math:`\\mathrm{len}\_\\mathrm{step}`
#     contains the calculated step length which should be displayed.
#
#     Parameters
#     ----------
#     link : string
#         Link to the diffusion data object generated by the
#         :func:`mc.MC.do_mc_cycles`
#     len_step : integer list, optional
#         List of the different step length, if it is None the lag times which
#         are contains in the obj file are printed
#     infty_profile : bool, optional
#         If its True only the profile for an infity lagtime is plotted
#     """
#     # Load Results from the output object file
#     results = utils.load(link)
#     diff_bin = results["diff_radial_profile"]
#     inp = results["model"]
#     dt = inp["len_frame"]
#     diff_unit = inp["diffusion radial unit"]
#     bins = inp["bins"]
#     bins = [(bins[i]) * 10**-8 for i in range(len(bins))]
#
#     if len_step is None:
#         len_step = inp["len_step"]
#
#     # Plot the diffusion profiles for the different lag times
#     legend = ["lagtime " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]
#
#     # Plot the diffusion profiles (m^2/s) for the
#     for i in len_step:
#         sns.lineplot(x=bins, y=np.exp(diff_bin[i] + diff_unit) * 10**-6)
#
#     # Averged profile over the selected lag times
#     if len(len_step) != 1 and avg:
#         diff_mean = np.zeros(len(bins[:-1]))
#         diff = []
#         for i in len_step:
#             diff_mean += diff_bin[i]
#         diff = [diff_mean[i]/len(len_step) for i in range(len(diff_mean))]
#
#         # Plot mean profile (m^2/s) over the selected lag times
#         sns.lineplot(x=bins, y=np.exp(diff + diff_unit) * 10**-6)
#         legend.append("avg profile")
#
#     # Set plot properties
#     plt.xlabel(r"Box length (m)")
#     plt.ylabel(r"radial Diffusion ($\mathrm{m^2s^{-1}}$)")
#     plt.legend(legend)
