################################################################################
# Diffusion                                                                    #
#                                                                              #
"""Analyse diffusion in a pore."""
################################################################################


import math
import warnings
import scipy as sp
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import itertools
import random

import poreana.utils as utils
import poreana.density as density


def cui(data_link, z_dist=0, ax_area=[0.2, 0.8], intent="", is_fit=False, is_plot=True):
    """This function samples and calculates the diffusion coefficient of a
    molecule group in a pore in both axial and radial direction, as described
    in the paper of `Cui <https://doi.org/10.1063/1.1989314>`_.

    The mean square displacement is sampled in function
    :func:`poreana.sample.diffusion_bin`.

    The axial diffusion is given by the Einstein relation

    .. math::

        \\langle\\left[z(0)-z(t)\\right]^2\\rangle=2D_\\text{axial}t

    with axial diffusion coefficient :math:`D_\\text{axial}`. Thus the
    coefficient corresponds to the slope of the axial msd

    .. math::

        D_\\text{axial}=\\frac12\\frac{\\text{msd}_\\text{axial}[i]-\\text{msd}_\\text{axial}[j]}{t_i-t_j}

    with bin :math:`i>j`. The radial diffusion is given by

    .. math::

        \\langle\\left[r(0)-r(t)\\right]^2\\rangle=R^2\\left[1-\\sum_{n=1}^\\infty\\frac{8}{\\lambda_{1n}^2(\\lambda_{1n}^2-1)}\\exp\\left(-\\frac{\\lambda_{1n}^2}{R^2}D_\\text{radial}t\\right)\\right].

    with radial diffusion coefficient :math:`D_\\text{radial}`, the maximal
    accessible radial position :math:`R` by an atom

    .. math::

        R = \\frac12d-0.2

    with pore diameter :math:`d`, and the zeros :math:`\\lambda_{1n}^2` of
    the derivative

    .. math::

        \\frac{dJ_1}{dx}

    of the first order Bessel function :math:`J_1`. Therefore the coefficient
    has to be fitted to the sampled radial msd. The author observed that
    the first 20 Bessel function zeros were sufficient for the function fit.

    The final unit transformation is done by

    .. math::

        \\frac{\\text{nm}^2}{\\text{ps}}=10^{-2}\\frac{\\text{cm}^2}{\\text{s}}.

    **Note that the function for the radial diffusion is obtained under the
    assumption that the density inside the pore is uniform.**

    Parameters
    ----------
    data_link : string
        Link to data object generated by the sample routine
        :func:`poreana.sample.diffusion_bin`
    z_dist : float, optional
        Distance from pore centre to calculate the mean
    ax_area : list, optional
        Bin area percentage to calculate the axial diffusion coefficient
    intent : string, optional
        axial, radial or empty for both
    is_fit : bool, optional
        True to plot the fitted function
    is_plot : bool, optional
        True to create plot in this function
    """
    # Load data object
    sample = utils.load(data_link)

    # Load data
    pore = sample["pore"]
    inp = sample["inp"]
    bins = inp["bin_num"] if not z_dist else math.floor(z_dist/sample["data"]["width"][1])
    msd_z = [0 for x in range(inp["len_window"])]
    msd_r = [0 for x in range(inp["len_window"])]
    norm_z = [0 for x in range(inp["len_window"])]
    norm_r = [0 for x in range(inp["len_window"])]

    # Sum up all bins
    for i in range(bins):
        for j in range(inp["len_window"]):
            msd_z[j] += sample["data"]["z_tot"][i][j]
            norm_z[j] += sample["data"]["n_tot"][i][j]

    for i in range(inp["bin_num"]):
        for j in range(inp["len_window"]):
            msd_r[j] += sample["data"]["r_tot"][i][j]
            norm_r[j] += sample["data"]["n_tot"][i][j]

    # Normalize
    msd_z_n = [msd_z[i]/norm_z[i] if norm_z[i] > 0 else 0 for i in range(inp["len_window"])]
    msd_r_n = [msd_r[i]/norm_r[i] if norm_r[i] > 0 else 0 for i in range(inp["len_window"])]

    # Define time axis and range
    time_ax = [x*inp["len_step"]*inp["len_frame"] for x in range(inp["len_window"])]
    t_range = (inp["len_window"]-1)*inp["len_step"]*inp["len_frame"]

    # Calculate axial coefficient
    if not intent or intent == "axial":
        dz = (msd_z_n[int(ax_area[1]*inp["len_window"])]-msd_z_n[int(ax_area[0]*inp["len_window"])])*1e-9**2/((ax_area[1]-ax_area[0])*t_range)/2*1e2**2*1e5  # 10^-9 m^2s^-1

        print("Diffusion axial:  "+"%.3f" % dz+" 10^-9 m^2s^-1")

    # Calculate radial coefficient
    if not intent or intent == "radial":
        def diff_rad(x, a, b, c):
            # Process input
            x = x if isinstance(x, list) or isinstance(x, np.ndarray) else [x]

            # Get bessel function zeros
            jz = sp.special.jnp_zeros(1, math.ceil(b))
            # Calculate sum
            sm = [[8/(z**2*(z**2-1))*math.exp(-(z/c)**2*a*t) for z in jz] for t in x]
            # Final equation
            return [c**2*(1-sum(s)) for s in sm]

        # Fit function
        popt, pcov = sp.optimize.curve_fit(diff_rad, [x*1e12 for x in time_ax], msd_r_n, p0=[1, 20, pore["diam"]/2-0.2], bounds=(0, np.inf))

        print("Diffusion radial: "+"%.3f" % (popt[0]*1e3)+" 10^-9 m^2 s^-1; Number of zeros: "+"%2i" % (math.ceil(popt[1]))+"; Radius: "+"%5.2f" % popt[2])

    # Plot
    if is_plot:
        legend = []

    if not intent or intent == "axial":
        sns.lineplot(x=[x*1e12 for x in time_ax], y=msd_z_n)
        if is_plot:
            legend += ["Axial"]
        if is_fit:
            sns.lineplot(x=[x*1e12 for x in time_ax], y=[dz*2*time_ax[x]/1e5/1e-7**2 for x in range(inp["len_window"])])
            legend += ["Fitted Axial"]

    if not intent or intent == "radial":
        sns.lineplot(x=[x*1e12 for x in time_ax], y=msd_r_n)
        if is_plot:
            legend += ["Radial"]
        if is_fit:
            sns.lineplot(x=[x*1e12 for x in time_ax], y=diff_rad([x*1e12 for x in time_ax], *popt))
            legend += ["Fitted Radial"]

    if is_plot:
        plt.xlabel("Time (ps)")
        plt.ylabel(r"Mean square displacement (nm$^2$)")
        plt.legend(legend)


def bins(data_link, ax_area=[0.2, 0.8], intent="plot", is_norm=False):
    """This function calculates the axial (z-axis) diffusion coefficient as a
    function of the radial distance. This is done by sampling the mean square
    displacement for all molecules in a radial sub volume.

    The mean square displacement is sampled in function
    :func:`poreana.sample.diffusion_bin`.

    For each bin, the msd is summed up, resulting into a msd slope for each
    bin. Thus, the axial diffusion coefficient can be calculated using

    .. math::

        D_\\text{axial}=\\frac12\\frac{\\text{msd}_\\text{axial}[i]-\\text{msd}_\\text{axial}[j]}{t_i-t_j}.

    Note that the msd is evaluated in the area, where the slope is uniform,
    which means that the first twenty and last twenty percent should be
    neglected.

    If ``is_norm`` is set to **True**, the radius will be normalized in respect
    to the effective radius which means, the last radius that has a
    Diffusion greater than zero is taken

    .. math::

        r_\\text{norm}=\\frac{1}{r_\\text{eff}}r.

    Parameters
    ----------
    data_link : string
        Link to data object generated by the sample routine :func:`poreana.sample.diffusion_bin`
    ax_area : list, optional
        Bin area percentage to calculate the axial diffusion coefficient
    intent : string, optional
        Set to **plot**, for plotting or set to **line** to only return the
        lineplot, leave empty for nothing
    is_norm : bool, optional
        True to normalize x-axis

    Returns
    -------
    diffusion : list
        List of the slope of the non-normalized diffusion coefficient
    """
    # Load data object
    sample = utils.load(data_link)

    # Load data
    inp = sample["inp"]
    width = sample["data"]["width"]
    msd_z = sample["data"]["z"]
    norm = sample["data"]["n"]

    # Normalize
    msd_norm = [[msd_z[i][j]/norm[i][j] if norm[i][j] > 0 else 0 for j in range(inp["len_window"])] for i in range(inp["bin_num"]+1)]

    # Calculate slope
    f_start = int(ax_area[0]*inp["len_window"])
    f_end = int(ax_area[1]*inp["len_window"])
    time_ax = [x*inp["len_step"]*inp["len_frame"] for x in range(inp["len_window"])]
    slope = [(msd_norm[i][f_end]-msd_norm[i][f_start])/(time_ax[f_end]-time_ax[f_start]) for i in range(inp["bin_num"]+1)]

    # Calculate diffusion coefficient
    diff = [msd*1e-9**2/2*1e2**2*1e5 for msd in slope]  # 10^-9 m^2s^-1

    # Normalize x-axis
    if is_norm:
        for i in range(len(diff)-1, 0, -1):
            if diff[i] > 0:
                x_max = width[i+1]
                break

        bins_norm = [x/x_max for x in width]

    # Plot
    if intent == "plot" or intent == "line":
        x_axis = bins_norm if is_norm else width
        sns.lineplot(x=x_axis[:-1], y=diff)

    if intent == "plot":
        if is_norm:
            plt.xlabel("Normalized distance from pore center")
        else:
            plt.xlabel("Distance from pore center (nm)")
        plt.ylabel(r"Diffusion coefficient ($10^{-9}$ m${^2}$ s$^{-1}$)")

    return {"width": width, "diff": diff}


def mean(data_link_diff, data_link_dens, ax_area=[0.2, 0.8], is_norm=False, is_check=False):
    """This function uses the diffusion coefficient slope obtained from
    function :func:`bins` and the density slope of function
    :func:`poreana.density.calculate` to calculate a weighted diffusion
    coefficient inside the pore

    .. math::

        \\langle D_\\text{axial}\\rangle
        =\\frac{\\int\\rho(r)D_\\text{axial}(r)dA(r)}{\\int\\rho(r)dA(r)}.

    In a discrete form, following formula is evaluated

    .. math::

        \\langle D_\\text{axial}\\rangle=\\frac{\\sum_{i=1}^n\\rho(r_i)D_\\text{axial}(r_i)A(r_i)}{\\sum_{i=1}^n\\rho(r_i)A(r_i)}

    with the partial area

    .. math::

        A(r_i)=\\pi(r_i^2-r_{i-1}^2)

    of radial bin :math:`i`.

    Parameters
    ----------
    data_link_dens : string
        Link to density data object generated by the sample rountine
        :func:`poreana.sample.density`
    data_link_diff : string
        Link to diffusion data object generated by the sample routine
        :func:`poreana.sample.diffusion_bin`
    ax_area : list, optional
        Bin area percentage to calculate the axial diffusion coefficient
    is_norm : bool, optional
        True to normalize x-axis
    is_check : bool, optional
        True to plot density function fit

    Returns
    -------
    diff_weight : float
        Density weighted mean axial diffusion in 10^-9 m^2s^-1
    """
    # Load data
    dens = density.calculate(data_link_dens, is_print=False)
    diff_bin = bins(data_link_diff, ax_area=ax_area, intent="", is_norm=is_norm)

    # Get number of bins
    bin_num = len(diff_bin["width"][:-1])

    # Set diffusion functions
    width = diff_bin["width"][:-1]
    diff = diff_bin["diff"]

    # Fit density function
    with warnings.catch_warnings():
        warnings.filterwarnings('ignore', r'Polyfit may be poorly conditioned')
        param = np.polyfit(dens["sample"]["data"]["in_width"][:-1], dens["num_dens"]["in"], 100)
        dens_f = np.poly1d(param)(width)

    # Plot fit
    if is_check:
        sns.lineplot(x=dens["sample"]["data"]["in_width"][:-1], y=dens["num_dens"]["in"])
        sns.lineplot(x=width, y=dens_f)

    # Integrate density
    dens_int = sum([dens_f[i]*(width[i+1]**2-width[i]**2) for i in range(bin_num-1)])

    # Calculate weighted diffusion
    diff_int = sum([dens_f[i]*diff[i]*(width[i+1]**2-width[i]**2) for i in range(bin_num-1)])

    # Normalize
    diff_weight = diff_int/dens_int

    print("Mean Diffusion axial: "+"%.3f" % diff_weight+" 10^-9 m^2s^-1")

    return diff_weight




################################################################################
# MC fusion                                                                    #
#                                                                              #
"""Analyse diffusion in a pore with the MC Diffusion Method."""
################################################################################

#############
# Diffusion #
#############
def diffusion_fit(link, len_step=[], is_std = True):
    """
    This function uses the diffusion profiles over box length which are
    calculated in the function :func:`do_mc_cycles` to estimate the final
    diffusion coefficient. For that a line is fitted of the averaged diffusion
    profiles :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}})` for the different lag
    times as a function of :math:`1/\\Delta_{ij}t_{\\alpha}`. The function plots
    all mean diffusion :math:`D_{mean}({\\Delta_{ij}t_{\\alpha}})` over the
    inverse lag times and the linear fit. Additional the final mean diffusion
    coefficient :math:`D` for a lagtime
    :math:`\\Delta_{ij}t_{\\alpha} \\rightarrow \infty` is printed. Also a table
    of the selected step length and the belonging
    :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}})` can be displayed.

    In order to be able to estimate how the choice of lag times affects the
    result, an additional error estimation is possible. For this all possible
    fourth tuples of the entire calculated lag times are used to estimate a
    mean diffusion coefficient :math:`\\langle D \\rangle` which is the mean
    value of all fourth tuples fitting results. Also the standard deviation of
    all fitting results is printed. If there is no big difference between the
    diffusion coefficient :math:`D` and the mean diffusion ceofficient
    :math:`\\langle D \\rangle`, all :math:`D_{mean}({\\Delta_{ij}t_{\\alpha}})`
    are on a straight line. The standard deviation can also be used to check
    if the result fluctuates strongly at the choice of other lag times. This
    error estimate is calculated if :math:`\\mathrm{is}\_{\\mathrm{std}}=True`.

    Parameters
    ----------
    link: string
        link to the diffusion data object generated by the sample routine
        :func:`MC.do_mc_cycles`
    len_step: integer list, optional
        list of the different step length, if it is None the lag times which
        are contains in the obj file are printed
    is_std : bool, optional
        if it is true a mean diffusion coefficient and a Bootstrap diffusion
        is calculated to be able to assess the dependency of the results on the
        chosen lag time

    Returns
    -------
    diffusion: float
        diffusion coefficient :math:`D \ \\left(\\frac{m^2}{s}\\right)` for the
        calculated system
    diffusion_mean: float
        mean diffusion coefficient :math:`\\langle D \\rangle \ \\left(\\frac{m^2}{s}\\right)` for the
        calculated system
    diff_table : obj
        table of used lag times with the associated
        :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}}) \ \\left(\\frac{m^2}{s}\\right)`
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_profile"]
    inp = results["model"]
    diff_unit = inp["diffusion unit"]
    dt = inp["len_frame"]

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
        len_step = inp["len_step"]

    # Calculate mean diffusion coefficient and standard deviation
    # Mean diffusion means the averaged of all pssible fourth tuple fitting results
    if is_std:
        len_step_all = len_step

        # Determine all possible combinations
        a = list(itertools.combinations(len_step_all,2))

        # Allocate the results vector
        res = np.zeros(len(a))

        # Fit for all combinations
        for i in range(len(a)):

            # set the current tuple
            rand = list(a[i])

            # Calculate the mean diffusion over all bins
            D_mean = [np.mean(np.exp(diff_bin[i] + diff_unit)) * 10**-6 for i in rand]  # Diffusion in m^2/s

            # Calculate the inverse lag time for the linear fit
            lagtime_inverse = [ 1 / (i * dt * 10**-12) for i in rand]   # Inverse lagtime in s

            # fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

            # set the x value for the linear fit
            x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5 )

            # Set the fitted diffusion coefficient on the results list
            res[i] = fit(0)

        # Determine standard deviation and mean diffusion of fourth touple method
        diffusion_mean = np.mean(res)
        std = res.std()


    # Calculate the mean diffusion over all bins
    D_mean = [np.mean(np.exp(diff_bin[i] + diff_unit)) * 10**-6 for i in len_step]   # Diffusion in m^2/s

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]   # Inverse lagtime in s

    # fit a linear line
    fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

    # Calculate the diffusion coefficient as a mean value over the bin
    print("\nDiffusion axial: "+"%.4e" % fit(0)  +" m^2/s\n\n")

    # If is_std true print the results of the calculations
    if is_std:
        print("\nMean Diffusion axial: "+"%.4e" % diffusion_mean  +" m^2/s\n\n")
        print("\nStandard deviation: "+"%.4e" % std  +" m^2/s\n\n")

    # Set data frame for the used lag times
    data = [str("%.2e" % D_mean[i]) + " $\mathrm{m^2s^{-1}}$" for i in range(len(len_step))]
    diff_table = pd.DataFrame(data,index=list(len_step),columns=list(['$D_\mathrm{mean}$']))
    diff_table = pd.DataFrame(diff_table.rename_axis('Step Length', axis=1))
    styler = diff_table.style.set_caption('Selected step length')
    diff_table =styler.set_properties(**{'text-align': 'right'})
    diff_table = diff_table.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])

    # Set vectors for plotting
    D_mean_vec = [D_mean[i] * 10 ** 9 for i in range(len(lagtime_inverse))]
    lag_time_vec = [ 1 / (len_step[i] * dt) for i in range(len(len_step))]
    x_vec = x = np.arange(0, max(lag_time_vec) * 2, (max(lag_time_vec) * 2) / 5 )

    # fit a linear line
    fit = np.poly1d(np.polyfit(lag_time_vec,D_mean_vec,1))

    # Plot the results
    plt.xlim(0,1.5*max(lag_time_vec))
    plt.ylim(0,1.5*max(fit(x_vec)))
    sns.scatterplot(x=lag_time_vec, y=D_mean_vec,color ='red')
    sns.lineplot(x=x_vec, y=fit(x_vec))
    legend = ["$D_{\mathrm{fit}}$","$D_{\mathrm{mean}}(\Delta_{ij}t_{\\alpha})$"]
    plt.legend(legend)
    plt.xlabel(r"Inverse lag time ($10^{12} \ \mathrm{s^{-1}})$")
    plt.ylabel(r"Diff. coeff. ($10^{-9} \ \mathrm{m^2s^{-1}}$)")

    diffusion = fit(0) * 10**-9

    return diffusion, diffusion_mean, diff_table

def diff_profile(link,len_step=[], infty_profile = True):
    """
    This function plots the diffusion profile for a infinity
    lag time (:math:`\\Delta_{ij}t_{\\alpha} \\rightarrow \\infty`) over the box
    fitted with the specified :math:`\\mathrm{len}\_\\mathrm{step}` list.
    Additionally, it is possible to display the diffusion profiles for the
    calculated lag times. Therefore, the
    :math:`\\mathrm{infty}\_\\mathrm{profile}` has to be false.
    The list :math:`\\mathrm{len}\_\\mathrm{step}`
    contains the calculated step length which should be
    displayed.

    Parameters
    ----------
    link : string
        link to the diffusion data object generated by the
        :func:`mc.MC.do_mc_cycles`
    len_step : integer list, optional
        list of the different step length, if it is None the lag times which
        are contains in the obj file are printed
    infty_profile : bool, optional
        if its True only the profile for an infity lagtime is plotted
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_profile"]
    df_bin = results["df_profile"]
    inp = results["model"]
    diff_unit = inp["diffusion unit"]
    dt = inp["len_frame"]
    bins = inp["bins"]
    bins = [(bins[i] + (bins[1]-bins[0])) for i in range(len(bins))]
    legend = []

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
            len_step = inp["len_step"]

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]   # Inverse lagtime in s

    # Calculate diffusion profiles
    diff_profiles = [[np.exp(diff_bin[i][j] + diff_unit) * 10**3 for j in range(len(bins))] for i in len_step ]

    # If infty_profile is false the profiles for the different lag times are plotted
    if infty_profile == False:
        # Plot the profiles for the
        for i in range(len(len_step)):
            sns.lineplot(x=bins, y=(diff_profiles[i]))       # Diffusion in m^2/s

        # Plot the diffusion profiles for the different lag times
        legend = ["lag time " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

    # If infty_profile is True the diffusion profile for a infinity lag times is shwon
    if len(len_step)>=2 and infty_profile == True:

        # Initialize fit vector
        diff_profile_fit = []

        # Calculate the mean diffusion over all bins
        for i in range(len(bins)):
            diff = [np.exp(diff_bin[step][i] + diff_unit) * 10**-6 for step in len_step]   # Diffusion in m^2/s

            # fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse,diff,1))

            #Append diffusion at t-> infty
            diff_profile_fit.append(fit(0)*10**9)

        # Plot fitted diffusion profile
        sns.lineplot(x=bins, y = diff_profile_fit )       # Diffusion in m^2/s

    # Set legend for lag times
    if infty_profile == False:
        # Add legend
        legend.append("Lagtime $\\infty$ ps")
        plt.legend(legend)

    # Set plot properties
    plt.xlabel(r"Box length (nm)")
    plt.ylabel(r"Diffusion ($10^{-9} \ \mathrm{m^2s^{-1}}$)")


##################
# Pore Diffusion #
##################
def diffusion_pore_fit(link_pore, link, len_step=[], is_std=True):
    """
    This function uses the diffusion profiles in the pore area which are
    calculated in the function :func:`do_mc_cycles` to estimate the final
    diffusion coefficient. For that a line is fitted of the averaged diffusion
    profiles :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}})` for the different lag
    times as a function of :math:`1/\\Delta_{ij}t_{\\alpha}`. The function plots
    all mean diffusion :math:`D_{mean}({\\Delta_{ij}t_{\\alpha}})` over the
    inverse lag times and the linear fit. Additional the final mean diffusion
    coefficient :math:`D` for a lagtime
    :math:`\\Delta_{ij}t_{\\alpha} \\rightarrow \infty` is printed. Also a table
    of the selected step length and the belonging
    :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}})` can be displayed.

    In order to be able to estimate how the choice of lag times affects the
    result, an additional error estimation is possible. For this all possible
    fourth tuples of the entire calculated lag times are used to estimate a
    mean diffusion coefficient :math:`\\langle D \\rangle` which is the mean
    value of all fourth tuples fitting results. Also the standard deviation of
    all fitting results is printed. If there is no big difference between the
    diffusion coefficient :math:`D` and the mean diffusion ceofficient
    :math:`\\langle D \\rangle`, all :math:`D_{mean}({\\Delta_{ij}t_{\\alpha}})`
    are on a straight line. The standard deviation can also be used to check
    if the result fluctuates strongly at the choice of other lag times. This
    error estimate is calculated if :math:`\\mathrm{is}\_{\\mathrm{std}}=True`.

    Parameters
    ----------
    link: string
        link to the diffusion data object generated by the sample routine
        :func:`MC.do_mc_cycles`
    len_step: integer list, optional
        list of the different step length, if it is None the lag times which
        are contains in the obj file are printed
    is_std : bool, optional
        if it is true a mean diffusion coefficient and a Bootstrap diffusion
        is calculated to be able to assess the dependency of the results on the
        chosen lag time

    Returns
    -------
    diffusion_pore: float
        diffusion coefficient :math:`D \ \\left(\\frac{m^2}{s}\\right)`
        in the pore area
    diffusion_pore_mean: float
        mean diffusion coefficient
        :math:`\\langle D \\rangle \ \\left(\\frac{m^2}{s}\\right)`
        in the pore area
    diff_table : obj
        table of used lag times with the associated
        :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}}) \ \\left(\\frac{m^2}{s}\\right)`
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_profile"]
    df_bin = results["df_profile"]
    inp = results["model"]
    bins = inp["bins"]
    diff_unit = inp["diffusion unit"]
    dt = inp["len_frame"]
    bins = [(bins[i] + (bins[1]-bins[0]))   for i in range(len(bins))]
    diff_bin_pore = {}
    diff = np.zeros(len(bins))

    # Load pore obj file
    pore = utils.load(link_pore)
    res = pore.reservoir()
    box = pore.box()

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
        len_step = inp["len_step"]

    # Cut profile (chose only the pore area for fitting)
    # Calculated start and end bin index of the pore area
    index_start = np.digitize(res,bins)
    index_end  = np.digitize((res + box[2]), bins)

    #Save for all lag times the cutted profile
    for i in len_step:
            diff_bin_pore[i] = {}
            diff = diff_bin[i]
            diff_bin_pore[i] = diff[index_start:index_end]


    # If is_std true print the results of the calculations
    if is_std:
        len_step_all = len_step

        # Determine all possible combinations
        a = list(itertools.combinations(len_step_all,2))

        # Allocate the results vector
        res = np.zeros(len(a))

        # Fit for all combinations
        for i in range(len(a)):

            # set the current tuple
            rand = list(a[i])

            # Calculate the mean diffusion over all bins
            D_mean = [np.mean(np.exp(diff_bin_pore[i] + diff_unit)) * 10**-6 for i in rand]  # Diffusion in m^2/s

            # Calculate the inverse lag time for the linear fit
            lagtime_inverse = [ 1 / (i * dt) for i in rand]   # Inverse lagtime in s

            # fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

            # set the x value for the linear fit
            x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5 )

            # Set the fitted diffusion coefficient on the results list
            res[i] = fit(0)

        # Determine standard deviation and mean diffusion of fourth touple method
        diffusion_pore_mean = np.mean(res)
        std = res.std()

    # Calculate the mean diffusion over all bins
    D_mean_all = [np.mean(np.exp(diff_bin_pore[i] + diff_unit)) * 10**3 for i in len_step]   # Diffusion in m^2/s

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse_all = [ 1 / (len_step[i] * dt ) for i in range(len(len_step))]   # Inverse lagtime in s

    # Plot the diffusion profiles for the different lag times
    legend = ["lagtime " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

    # fit a linear line
    fit = np.poly1d(np.polyfit(lagtime_inverse_all,D_mean_all,1))

    # set the x value for the linear fit
    x = np.arange(0, max(lagtime_inverse_all) * 2, (max(lagtime_inverse_all) * 2) / 5 )

    # Calculate the diffusion coefficient as a mean value over the bin
    print("\nDiffusion axial: "+"%.4e" % (float(fit(0)) * 10 **-9)  +" m^2/s\n\n")

    # If is_std true print the results of the calculations
    if is_std:
        # Print results
        print("\nMean Diffusion axial: "+"%.4e" % diffusion_pore_mean  +" m^2/s\n\n")
        print("\nStandard deviation: "+"%.4e" % std  +" m^2/s\n\n")

    # Set vectors for plotting
    D_mean_vec = [D_mean_all[i] for i in range(len(lagtime_inverse_all))]
    lag_time_vec = [ 1 / (len_step[i] * dt) for i in range(len(len_step))]
    x_vec = x = np.arange(0, max(lag_time_vec) * 2, (max(lag_time_vec) * 2) / 5 )

    # Set data frame for the used lag times
    data = [str("%.4e" % (D_mean_all[i] * 10**-9)) + " $\mathrm{m^2s^{-1}}$" for i in range(len(len_step))]
    diff_table = pd.DataFrame(data,index=list(len_step),columns=list(['$D_\mathrm{mean}$']))
    diff_table = pd.DataFrame(diff_table.rename_axis('Step Length', axis=1))
    styler = diff_table.style.set_caption('Selected step length')
    diff_table =styler.set_properties(**{'text-align': 'right'})
    diff_table = diff_table.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])

    # Plot the results
    plt.xlim(0,1.5*max(lag_time_vec))
    plt.ylim(0,1.5*max(fit(x_vec)))
    sns.scatterplot(x=lag_time_vec, y=D_mean_vec,color ='red')
    sns.scatterplot(x=[0.0], y=[fit(0)],color ='black')
    sns.lineplot(x=x_vec, y=fit(x))
    legend = ["$D_{\mathrm{fit}}$","$D_{\mathrm{mean}}(\Delta_{ij}t_{\\alpha})$"]
    plt.legend(legend)
    plt.xlabel(r"Inverse lagtime ($10^{12} \ \mathrm{s^{-1}})$")
    plt.ylabel(r"Diff. coeff. ($10^{-9} \ \mathrm{m^2s^{-1}}$)")

    diffusion_pore = fit(0) * 10 **-9

    return diffusion_pore, diffusion_pore_mean, diff_table

def diff_pore_profile(link_pore, link, len_step=[], infty_profile = False):
    """
    This function plots the diffusion profile in the pore areas for a infinity
    lag time (:math:`\\Delta_{ij}t_{\\alpha} \\rightarrow \\infty`) over the box
    fitted with the specified :math:`\\mathrm{len}\_\\mathrm{step}` list.
    Additionally, it is possible to display the diffusion profiles for the
    calculated lag times. Therefore, the
    :math:`\\mathrm{infty}\_\\mathrm{profile}` has to be false.
    The list :math:`\\mathrm{len}\_\\mathrm{step}`
    contains the calculated step length which should be
    displayed.

    Parameters
    ----------
    link : string
        link to the diffusion data object generated by the
        :func:`mc.MC.do_mc_cycles`
    len_step : integer list, optional
        list of the different step length, if it is None the lag times which
        are contains in the obj file are printed
    infty_profile : bool, optional
        if its True only the profile for an infity lagtime is plotted
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_profile"]
    df_bin = results["df_profile"]
    inp = results["model"]
    bins = inp["bins"]
    diff_unit = inp["diffusion unit"]
    dt = inp["len_frame"]
    bins = [(bins[i] + (bins[1]-bins[0]))   for i in range(len(bins))]
    diff_bin_pore = {}
    diff = np.zeros(len(bins))
    # Load pore obj file
    pore = utils.load(link_pore)
    res = pore.reservoir()
    box = pore.box()
    legend = []

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
        len_step = inp["len_step"]

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]   # Inverse lagtime in s

    # Cut profile (chose only the pore area)
    # Calculated start and end bin index of the pore area
    index_start = np.digitize(res,bins)
    index_end  = np.digitize((res + box[2]), bins)

    #Save for all lag times the cutted profile
    for i in len_step:
            diff_bin_pore[i] = {}
            diff = diff_bin[i]
            diff_bin_pore[i] = diff[index_start:index_end]

    # List with the bins in the pore
    bins_pore = [bins[i] - res for i in range(index_start,index_end)]

    # Determine diffusion profile in the pore area
    diff_bin_pore = [[np.exp(diff_bin_pore[j][i] + diff_unit) * 10 ** 3 for i in range(len(bins_pore))] for j in len_step]

    # If infty_profile is false the profiles for the different lag times are plotted
    if infty_profile == False:
        # Plot the diffusion profiles for the different lag times
        legend = ["lag time " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

        # Plot the profiles for the
        for i in range(len(len_step)):
            sns.lineplot(x=(bins_pore), y=diff_bin_pore[i])       # Diffusion in m^2/s


    # If infty_profile is True the diffusion profile for a infinity lag times is shwon
    if len(len_step)>=2 and infty_profile == True:
        # Initialize fit vector
        diff_profile_fit = []

        # Calculate the mean diffusion over all bins
        for i in range(len(bins_pore)):
            diff = [diff_bin_pore[step][i] for step in range(len(len_step))]   # Diffusion in m^2/s

            # fit a linear line
            fit = np.poly1d(np.polyfit(lagtime_inverse,diff,1))

            #Append diffusion at t-> infty
            diff_profile_fit.append(fit(0))

        # Plot fitted diffusion profile
        sns.lineplot(x=(bins_pore), y = diff_profile_fit)       # Diffusion in m^2/s

    # Set legend for lag times
    if infty_profile == False:
        # Add legend
        legend.append("Lagtime $\\infty$ ps")
        plt.legend(legend)

    # Set plot properties
    plt.xlabel(r"Pore length (nm)")
    plt.ylabel(r"Diffusion ($\mathrm{m^2s^{-1}}$)")

###############
# Free Energy #
###############
def df_profile(link,len_step=[]):
    """
    This function plots the free energy profile over the box for the calculated
    lag times. In contrast to the diffusion profile the diffusion profile has
    not a dependency on the lag time. If the free energy profiles are not close
    to equal the calculation is incorrect.

    Parameters
    ----------
    link : string
        link to the diffusion data object generated by the :func:`do_mc_cycles`
    len_step: integer list, optional
        list of the different step length, if it is None the lag times which
        are contains in the obj file are printed
    """

    # Load Results from the output object file
    results = utils.load(link)
    df_bin = results["df_profile"]
    inp = results["model"]
    dt = inp["len_frame"]
    bins = inp["bins"]

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
        len_step = inp["len_step"]

    # Set legend
    legend = ["lagtime " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

    # Plot the free energy profiles
    for i in len_step:
         sns.lineplot(x=bins, y=(df_bin[i]))

    # Plot options
    plt.xlabel(r"Box length (nm)")
    plt.ylabel(r"Free energy (-)")
    plt.legend(legend)


#################
# Pandas Tables #
#################
def print_statistics_mc(link_out, print_con=False):
    """
    This function prints the statistic of the MC Run for every lag time.

    Parameters
    ----------
    link_out: string
        link to the diffusion data object generated by the sample routine
        :func:`moldyn.pores.mcdiff.mc.do_mc_cycles`

    Returns
    -------
    df_results: obj
        data frame of the MC Alogrithm statistics
    print_con: bool, optional
        if its true the table can be print in console
    """

    # If a data object output as an input take the results
    results = utils.load(link_out)
    model = results["model"]
    len_step = model["len_step"]
    inp = results["inp"]
    nmc_eq = inp["MC steps eq"]
    nmc = inp["MC steps"]
    nmc_radial_eq = inp["MC steps radial eq"]
    nmc_radial = inp["MC steps radial"]
    num_mc_update = inp["step width update"]
    print_freq = inp["print freq"]

    #Read MC statistic
    nacc_df_mean = results["nacc_df"]
    nacc_diff_mean = results["nacc_diff"]
    list_diff_fluc = results["fluc_diff"]
    list_df_fluc = results["fluc_df"]


    # Table for MC Statistics
    data = [[str("%.4e" % list_df_fluc[i]) for i in len_step],[str("%.4e" % list_diff_fluc[i]) for i in len_step],[str("%.0f" % nacc_df_mean[i]) for i in len_step],[str("%.0f" % nacc_diff_mean[i]) for i in len_step],[str("%.2f" % (nacc_df_mean[i]*100/(nmc+nmc_eq))) for i in len_step],[str("%.2f" % (nacc_diff_mean[i]*100/(nmc+nmc_eq))) for i in len_step]]

    # Set index of panda table
    df_results = pd.DataFrame(data,index=list(['fluctuation df','fluctuation diff','acc df steps','acc diff steps','acc df steps (%)','acc diff steps (%)']),columns=list(len_step))

    # If the table has to print in console
    if print_con==True:
        print('\nStatistics of the MC Algorithm')
        print(df_results)

    # Set styler for pandas table in jupyter
    df_results = pd.DataFrame(df_results.rename_axis('Step Length', axis=1))
    styler = df_results.style.set_caption('Statistics of the MC Algorithm')
    df_results = styler.set_properties(**{'text-align': 'right'})
    df_results = df_results.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])

    return df_results


def print_coeff(link_out, print_con=False):
    """
    This function prints the final coefficients of the profile for
    every lag time profile.

    Parameters
    ----------
    link_out: string
        link to the diffusion  data object generated by the sample
        routine :func:`poreana.post_process.do_mc_cycles`

    Returns
    -------
    df_results: obj
        data frame of the MC Alogrithm statistics
    print_con: bool, optional
        if its true the table can be print in console
    """

    # If a data object output as an input take the results
    results = utils.load(link_out)
    model = results["model"]
    len_step = model["len_step"]
    diff_coeff = results["list_diff_coeff"]
    df_coeff = results["list_df_coeff"]
    nD = model["nD"]
    nF = model["nF"]

    # Initialize data dictionary for the diffusion profile coefficients
    data = {}

    # Save diffusion profile coefficients on data dictionary
    for i in len_step:
        data[i] = [str("%.4e" % diff_coeff[i][j]) for j in range(nD)]

    # Pandas table
    diff_coeff = pd.DataFrame(data,index=list(np.arange(1,nD+1)),columns=list(len_step))
    diff_coeff = pd.DataFrame(diff_coeff.rename_axis('Step Length', axis=1))

    # If the table has to print in console
    if print_con==True:
        print('\nDiffusion coefficients')
        print(diff_coeff)

    # Set styler for pandas table in jupyter
    styler = diff_coeff.style.set_caption('Diffusion coefficients')
    diff_coeff = styler.set_properties(**{'text-align': 'right'})
    diff_coeff = diff_coeff.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])


    # Initialize data dictionary for the diffusion profile coefficients
    data = {}

    # Save free energy profile coefficients on data dictionary
    for i in len_step:
        data[i] = [str("%.4e" % df_coeff[i][j]) for j in range(nF)]

    # Pandas table
    df_coeff = pd.DataFrame(data,index=list(np.arange(1,nF+1)),columns=list(len_step))
    df_coeff = pd.DataFrame(df_coeff.rename_axis('Step Length', axis=1))

    # If the table has to print in console and not in a jupyter notebook
    if print_con==True:
        print('\nFree energy coefficients')
        print(df_coeff)

    # Set styler for pandas table in jupyter
    styler = df_coeff.style.set_caption('Free energy coefficients')
    df_coeff = styler.set_properties(**{'text-align': 'right'})
    df_coeff = df_coeff.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])

    return diff_coeff, df_coeff


def print_model_inputs(link_out, print_con=False):
    """
    This function prints the model inputs of the calculation.

    Parameters
    ----------
    link_out: string
        link to the diffusion data object generated by the sample
        routine :func:`moldyn.pores.mcdiff.mc.do_mc_cycles`

    Returns
    -------
    df_model: obj
        data frame of the model inputs
    print_con: bool, optional
        if its true the table can be print in console
    """
    # Read model inputs
    results = utils.load(link_out)
    model = results["model"]
    bin_number = model["bin number"]
    len_step = model["len_step"]
    len_frame = model["len_frame"]
    frame_num = model["num_frame"]
    nD = model["nD"]
    nF = model["nF"]
    nDrad = model["nDrad"]
    d = model["guess"]
    model = model["model"]

    # String which contains all lag times
    len_step_string = ', '.join(str(step) for step in len_step)

    # dictionary for model inputs
    data = [str("%.f" % bin_number),len_step_string,str("%.2e" % (len_frame * 10**(-12))),str("%.f" % frame_num),str("%.f" % nD),str("%.f" % nF),str("%.f" %nDrad),model,str("%.2e" % (d * 10**(-6)))]
    df_model = pd.DataFrame(data,index=list(['Bin number','step length','frame length (s)', 'frame number','nD','nF','nDrad','model','guess diffusion (m2/s-1)']),columns=list(['Input']))

    # If the table has to print in console and not in a jupyter notebook
    if print_con==True:
        print('\nModel Inputs')
        print(df_model)

    # Set styler for pandas table in jupyter
    styler = df_model.style.set_caption('Model Inputs')
    df_model = styler.set_properties(**{'text-align': 'right'})
    df_model = df_model.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])

    return df_model

def print_mc_inputs(link_out, print_con=False):
    """
    This function prints the MC Algorithm inputs of the calculation.

    Parameters
    ----------
    link_out: string
        link to the diffusion data object generated by the sample
        routine :func:`moldyn.pores.mcdiff.mc.do_mc_cycles`

    Returns
    -------
    df_mc: obj
        data frame of the MC Alogrithm inputs
    print_con: bool, optional
        if its true the table can be print in console
    """

    # Load Results from the output object file
    results = utils.load(link_out)

    # Read MC inputs
    inp = results["inp"]
    nmc_eq = inp["MC steps eq"]
    nmc = inp["MC steps"]
    nmc_radial_eq = inp["MC steps radial eq"]
    nmc_radial = inp["MC steps radial"]
    num_mc_update = inp["step width update"]
    print_freq = inp["print freq"]

    # Table for MC Inputs
    data = [nmc_eq,nmc,nmc_radial_eq,nmc_radial,num_mc_update,print_freq]
    df_mc = pd.DataFrame(data,index=list(['MC steps (Equilibrium)','MC steps (Production)','radial MC steps (Equilibrium)','radial MC step (Production)','movewidth update frequency','print frequency']),columns=list(['Input']))

    # If the table has to print in console and not in a jupyter notebook
    if print_con==True:
        print('\nMC Inputs')
        print(df_mc)

    # Set style for the pandas table
    styler = df_mc.style.set_caption('MC Inputs')
    df_mc = styler.set_properties(**{'text-align': 'right'})
    df_mc = df_mc.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])

    return df_mc


##########################
# Plot transition matrix #
##########################
def plot_trans_mat(link_in,step,kwargs={}):
    """
    This function plots the occupation of a normalized transition matrix as a
    heatmap. To normalize the matrix the number of the frame are used.

    Parameters
    ----------
    link_out: string
        link to the diffusion data object generated by the sample
        routine :func:`poreana.post_process.do_mc_cycles` or :func:`Sample.sample`
    step: int
        step length for the trans matrix to be visualized
    kwargs: dict
        dictionary with heatmap parameters to adjust the transition heatmap
    """

    # Load Results from the output object file
    results = utils.load(link_in)

    # Check if mc obj files was loaded
    try:
        model = results["model"]
        trans_mat = model["data"]
        frame_num = model["num_frame"]
        frame_length = model["len_frame"]
    except:
        pass

    # Check if sample obj files was loaded
    try:
        trans_mat = results["data"]
        inp = results["inp"]
        frame_num = inp["num_frame"]
        frame_length = inp["len_frame"] * 10**12
    except:
        pass

    # Set title for the lag time
    plt.title("Lagtime: "+str(step * frame_length) + " ps", fontsize=10)

    # Plot the normalized transition matrix in a heat map
    # Without options for the heatmap plots
    if not kwargs:
        sns.heatmap(trans_mat[step]/frame_num)

    # With options for the heatmap plots
    else:
        sns.heatmap(trans_mat[step]/frame_num, **kwargs)


####################
# Radial Diffusion #
####################
def diffusion_radial_fit(link, len_step=None):
    """
    This function uses the diffusion profiles over box length which are
    calculated in the function :func:`do_mc_cycles` to estimate the final
    diffusion coefficient. For that a line is fitted of the averaged diffusion
    profiles :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}})` for the different lag
    times as a function of :math:`1/\\Delta_{ij}t_{\\alpha}`. The function plots
    all mean diffusion :math:`D_{mean}({\\Delta_{ij}t_{\\alpha}})` over the
    inverse lag times and the linear fit. Additional the final mean diffusion
    coefficient :math:`D` for a lagtime
    :math:`\\Delta_{ij}t_{\\alpha} \\rightarrow \infty` is printed. Also a table
    of the selected step length and the belonging
    :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}})` can be displayed.

    In order to be able to estimate how the choice of lag times affects the
    result, an additional error estimation is possible. For this all possible
    fourth tuples of the entire calculated lag times are used to estimate a
    mean diffusion coefficient :math:`\\langle D \\rangle` which is the mean
    value of all fourth tuples fitting results. Also the standard deviation of
    all fitting results is printed. If there is no big difference between the
    diffusion coefficient :math:`D` and the mean diffusion ceofficient
    :math:`\\langle D \\rangle`, all :math:`D_{mean}({\\Delta_{ij}t_{\\alpha}})`
    are on a straight line. The standard deviation can also be used to check
    if the result fluctuates strongly at the choice of other lag times. This
    error estimate is calculated if :math:`\\mathrm{is}_{\\mathrm{std}}=True`.

    Parameters
    ----------
    link: string
        link to the diffusion data object generated by the sample routine
        :func:`MC.do_mc_cycles`
    len_step: integer list, optional
        list of the different step length, if it is None the lag times which
        are contains in the obj file are printed
    is_std : bool, optional
        if it is true a mean diffusion coefficient and a Bootstrap diffusion
        is calculated to be able to assess the dependency of the results on the
        chosen lag time

    Returns
    -------
    diffusion: float
        radial diffusion coefficient :math:`D \ \\left(\\frac{m^2}{s}\\right)` for the
        calculated system
    diffusion_mean: float
        radial mean diffusion coefficient :math:`\\langle D \\rangle \ \\left(\\frac{m^2}{s}\\right)` for the
        calculated system
    diff_table : obj
        table of used lag times with the associated
        :math:`D_{\\mathrm{mean}}({\\Delta_{ij}t_{\\alpha}}) \ \\left(\\frac{m^2}{s}\\right)`
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_radial_profile"]
    df_bin = results["df_profile"]
    inp = results["model"]
    bins = inp["bins"]
    diff_unit = inp["diffusion radial unit"]
    dt = inp["len_frame"]

    # If no specific step length is chosen take the step length from the object file
    if not len_step:
        len_step = inp["len_step"]

    # Calculate the mean diffusion over all bins
    D_mean = [np.mean(np.exp(diff_bin[i] + diff_unit)) * 10**-6 for i in len_step]   # Diffusion in m^2/s

    # Calculate the inverse lag time for the linear fit
    lagtime_inverse = [ 1 / (len_step[i] * dt * 10**-12) for i in range(len(len_step))]   # Inverse lagtime in s

    # fit a linear line
    fit = np.poly1d(np.polyfit(lagtime_inverse,D_mean,1))

    # set the x value for the linear fit
    x = np.arange(0, max(lagtime_inverse) * 2, (max(lagtime_inverse) * 2) / 5 )


    # Calculate the diffusion coefficient as a mean value over the bin
    print("\nMean Radial Diffusion: "+"%.4e" % fit(0)  +" m^2/s\n")

    # Integration
    bin_width = bins[1]-bins[0]

    # Set data frame for the used lag times
    D_mean_pd = [str("%.2e" % D_mean[i]) for i in range(len(D_mean))]
    diff_table = pd.DataFrame({'$D_\mathrm{mean}$':D_mean_pd,'$D_\mathrm{avg} (\mathrm{m^2s^{-1}})$': diff_avg_pd},index=list(len_step))
    diff_table = pd.DataFrame(diff_table.rename_axis('Step Length', axis=1))
    styler = diff_table.style.set_caption('Selected step length')
    diff_table =styler.set_properties(**{'text-align': 'right'})
    diff_table = diff_table.set_table_styles([dict(selector = 'th', props=[('text-align', 'left')])])


    # Plot the results
    plt.xlim(0,1.5*max(lagtime_inverse))
    plt.ylim(0,1.5*max(fit(x)))
    sns.scatterplot(x=lagtime_inverse, y=D_mean,color ='red')
    sns.lineplot(x=x, y=fit(x))
    legend = ["linear fit","$D_{\mathrm{mean}}$"]
    plt.legend(legend)
    plt.xlabel(r"Inverse lagtime ($\mathrm{s^{-1}})$")
    plt.ylabel(r"radial Diff. coeff. ($\mathrm{m^2s^{-1}}$)")

    return fit(0),diff_table


def diff_radial_profile(link,len_step=None,avg=False):
    """
    This function plots the radial diffusion profile for a infinity
    lag time (:math:`\\Delta_{ij}t_{\\alpha} \\rightarrow \\infty`) over the box
    fitted with the specified :math:`\\mathrm{len}\_\\mathrm{step}` list.
    Additionally, it is possible to display the diffusion profiles for the
    calculated lag times. Therefore, the
    :math:`\\mathrm{infty}\_\\mathrm{profile}` has to be false.
    The list :math:`\\mathrm{len}\_\\mathrm{step}`
    contains the calculated step length which should be
    displayed.

    Parameters
    ----------
    link : string
        link to the diffusion data object generated by the
        :func:`mc.MC.do_mc_cycles`
    len_step : integer list, optional
        list of the different step length, if it is None the lag times which
        are contains in the obj file are printed
    infty_profile : bool, optional
        if its True only the profile for an infity lagtime is plotted
    """

    # Load Results from the output object file
    results = utils.load(link)
    diff_bin = results["diff_radial_profile"]
    inp = results["model"]
    dt = inp["len_frame"]
    diff_unit = inp["diffusion radial unit"]
    bins = inp["bins"]
    bins = [(bins[i]) * 10**-8   for i in range(len(bins))]

    if len_step is None:
        len_step = inp["len_step"]

    # Plot the diffusion profiles for the different lag times
    legend = ["lagtime " + str(len_step[i] * dt) + " ps" for i in range(len(len_step))]

    # Plot the profiles for the
    for i in len_step:
        sns.lineplot(x=bins, y=np.exp(diff_bin[i] + diff_unit) * 10**-6)       # Diffusion in m^2/s


    # Averged profile over the selected lag times
    if len(len_step) != 1 and avg==True:
        diff_mean = np.zeros(len(bins[:-1]))
        diff = []
        for i in len_step:
            diff_mean += diff_bin[i]
        diff = [diff_mean[i]/len(len_step) for i in range(len(diff_mean))]

        # Plot mean profile over the selected lag times
        sns.lineplot(x=bins, y=np.exp(diff + diff_unit) * 10**-6)       # Diffusion in m^2/s
        legend.append("avg profile")

    # Set plot properties
    plt.xlabel(r"Box length (m)")
    plt.ylabel(r"radial Diffusion ($\mathrm{m^2s^{-1}}$)")
    plt.legend(legend)
